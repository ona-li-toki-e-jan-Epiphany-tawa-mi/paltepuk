<!doctype html><html lang=en><title>GNU APL</title>
<meta name=description content="APL"><meta charset=utf-8><link rel=stylesheet href=style.css><h1 class=toc_H1>A Quick Tour of GNU APL</h1><table><tbody><tr class=toc_H2><td class=toc_c1>1<td class=toc_c2><a class=toc_a2 href=#CH_1>Document Conventions</a><tr class=toc_H3><td class=toc_c1>1.1<td class=toc_c2><a class=toc_a2 href=#CH_1.1>The Structure of the GNU APL Documentation</a><tr class=toc_H3><td class=toc_c1>1.2<td class=toc_c2><a class=toc_a2 href=#CH_1.2>Conventions in This Document</a><tr class=toc_H2><td class=toc_c1>2<td class=toc_c2><a class=toc_a2 href=#CH_2>Starting and stopping the APL interpreter</a><tr class=toc_H2><td class=toc_c1>3<td class=toc_c2><a class=toc_a2 href=#CH_3>APL Statements</a><tr class=toc_H3><td class=toc_c1>3.1<td class=toc_c2><a class=toc_a2 href=#CH_3.1>Constants (Literals)</a><tr class=toc_H4><td class=toc_c1>3.1.1<td class=toc_c2><a class=toc_a2 href=#CH_3.1.1>Scalar Constants</a><tr class=toc_H5><td class=toc_c1>3.1.1.1<td class=toc_c2><a class=toc_a2 href=#CH_3.1.1.1>Scalar Text Constants</a><tr class=toc_H5><td class=toc_c1>3.1.1.2<td class=toc_c2><a class=toc_a2 href=#CH_3.1.1.2>Numeric Scalar Constants</a><tr class=toc_H4><td class=toc_c1>3.1.2<td class=toc_c2><a class=toc_a2 href=#CH_3.1.2>Vector Constants</a><tr class=toc_H4><td class=toc_c1>3.1.3<td class=toc_c2><a class=toc_a2 href=#CH_3.1.3>Mixed Constants</a><tr class=toc_H4><td class=toc_c1>3.1.4<td class=toc_c2><a class=toc_a2 href=#CH_3.1.4>Nested Constants</a><tr class=toc_H4><td class=toc_c1>3.1.5<td class=toc_c2><a class=toc_a2 href=#CH_3.1.5>Multi-Line Strings</a><tr class=toc_H4><td class=toc_c1>3.1.6<td class=toc_c2><a class=toc_a2 href=#CH_3.1.6>Summary and Remarks</a><tr class=toc_H3><td class=toc_c1>3.2<td class=toc_c2><a class=toc_a2 href=#CH_3.2>APL Names</a><tr class=toc_H4><td class=toc_c1>3.2.1<td class=toc_c2><a class=toc_a2 href=#CH_3.2.1>User-defined Names</a><tr class=toc_H4><td class=toc_c1>3.2.2<td class=toc_c2><a class=toc_a2 href=#CH_3.2.2>Names of System Functions and System Variables</a><tr class=toc_H4><td class=toc_c1>3.2.3<td class=toc_c2><a class=toc_a2 href=#CH_3.2.3>Names of Primitive APL Functions</a><tr class=toc_H3><td class=toc_c1>3.3<td class=toc_c2><a class=toc_a2 href=#CH_3.3>Functions and Operators</a><tr class=toc_H4><td class=toc_c1>3.3.1<td class=toc_c2><a class=toc_a2 href=#CH_3.3.1>Niladic Functions</a><tr class=toc_H4><td class=toc_c1>3.3.2<td class=toc_c2><a class=toc_a2 href=#CH_3.3.2>Monadic Functions</a><tr class=toc_H4><td class=toc_c1>3.3.3<td class=toc_c2><a class=toc_a2 href=#CH_3.3.3>Dyadic Functions</a><tr class=toc_H4><td class=toc_c1>3.3.4<td class=toc_c2><a class=toc_a2 href=#CH_3.3.4>Monadic Operators</a><tr class=toc_H4><td class=toc_c1>3.3.5<td class=toc_c2><a class=toc_a2 href=#CH_3.3.5>Dyadic Operators</a><tr class=toc_H3><td class=toc_c1>3.4<td class=toc_c2><a class=toc_a2 href=#CH_3.4>General APL Values</a><tr class=toc_H4><td class=toc_c1>3.4.1<td class=toc_c2><a class=toc_a2 href=#CH_3.4.1>Reshape and Shape: ⍴</a><tr class=toc_H4><td class=toc_c1>3.4.2<td class=toc_c2><a class=toc_a2 href=#CH_3.4.2>Catenate and Ravel: , and ⍪</a><tr class=toc_H4><td class=toc_c1>3.4.3<td class=toc_c2><a class=toc_a2 href=#CH_3.4.3>Universal Character Set (monadic ⎕UCS)</a><tr class=toc_H4><td class=toc_c1>3.4.4<td class=toc_c2><a class=toc_a2 href=#CH_3.4.4>Construction of arbitrary simple values</a><tr class=toc_H4><td class=toc_c1>3.4.5<td class=toc_c2><a class=toc_a2 href=#CH_3.4.5>Construction of arbitrary nested values</a><tr class=toc_H4><td class=toc_c1>3.4.6<td class=toc_c2><a class=toc_a2 href=#CH_3.4.6>Displaying the structure of values</a><tr class=toc_H4><td class=toc_c1>3.4.7<td class=toc_c2><a class=toc_a2 href=#CH_3.4.7>Vector Notation versus Catenation</a><tr class=toc_H4><td class=toc_c1>3.4.8<td class=toc_c2><a class=toc_a2 href=#CH_3.4.8>Scalar Extension</a><tr class=toc_H4><td class=toc_c1>3.4.9<td class=toc_c2><a class=toc_a2 href=#CH_3.4.9>List of Built-in Scalar Functions</a><tr class=toc_H4><td class=toc_c1>3.4.10<td class=toc_c2><a class=toc_a2 href=#CH_3.4.10>List of Other Built-in Functions</a><tr class=toc_H4><td class=toc_c1>3.4.11<td class=toc_c2><a class=toc_a2 href=#CH_3.4.11>List of Built-in Monadic APL Operators</a><tr class=toc_H4><td class=toc_c1>3.4.12<td class=toc_c2><a class=toc_a2 href=#CH_3.4.12>List of Built-In Dyadic APL Operators</a><tr class=toc_H4><td class=toc_c1>3.4.13<td class=toc_c2><a class=toc_a2 href=#CH_3.4.13>Functions and Operators with Axis Argument</a><tr class=toc_H4><td class=toc_c1>3.4.14<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14>System Functions</a><tr class=toc_H5><td class=toc_c1>3.4.14.1<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.1>Z ← ⎕AF B : Atomic Function</a><tr class=toc_H5><td class=toc_c1>3.4.14.2<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.2>Z ← A ⎕AT B : Attributes</a><tr class=toc_H5><td class=toc_c1>3.4.14.3<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.3>Z ← A ⎕CR B : Character Representation</a><tr class=toc_H5><td class=toc_c1>3.4.14.4<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.4>Z ← ⎕DL B : Delay</a><tr class=toc_H5><td class=toc_c1>3.4.14.5<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.5>Z ← A ⎕DLX B : Donald Knuth's Dancing Links</a><tr class=toc_H5><td class=toc_c1>3.4.14.6<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.6>Z ← A ⎕EA B : Execute Alternate</a><tr class=toc_H5><td class=toc_c1>3.4.14.7<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.7>Z ← A ⎕EB B : Execute Both</a><tr class=toc_H5><td class=toc_c1>3.4.14.8<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.8>Z ← ⎕EC B : Execute Controlled</a><tr class=toc_H5><td class=toc_c1>3.4.14.9<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.9>Z ← ⎕ENV B : ENvironment Variables</a><tr class=toc_H5><td class=toc_c1>3.4.14.10<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.10>Z ← A ⎕ES B : Event Simulate</a><tr class=toc_H5><td class=toc_c1>3.4.14.11<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.11>Z ← ⎕EX B : EXpunge</a><tr class=toc_H5><td class=toc_c1>3.4.14.12<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.12>Z ← A ⎕FFT B : Fast Fourier Transform</a><tr class=toc_H5><td class=toc_c1>3.4.14.13<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.13>⎕FIO[X] B : File I/O functions</a><tr class=toc_H5><td class=toc_c1>3.4.14.14<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.14>Z ← ⎕FX B : FiX</a><tr class=toc_H5><td class=toc_c1>3.4.14.15<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.15>Z ← ⎕GTK B : Gtk GUI</a><tr class=toc_H5><td class=toc_c1>3.4.14.16<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.16>Z ← A ⎕JSON B : JSON parser</a><tr class=toc_H5><td class=toc_c1>3.4.14.17<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.17>Z ← A ⎕MAP B : MAP (replace) ravel elements</a><tr class=toc_H5><td class=toc_c1>3.4.14.18<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.18>Z ← ⎕INP B : INPut from script</a><tr class=toc_H5><td class=toc_c1>3.4.14.19<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.19>Z ← ⎕NA B : Name Association</a><tr class=toc_H5><td class=toc_c1>3.4.14.20<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.20>Z ← ⎕NC B : Name Class</a><tr class=toc_H5><td class=toc_c1>3.4.14.21<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.21>Z ← A ⎕NL B : Name List</a><tr class=toc_H5><td class=toc_c1>3.4.14.22<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.22>Z ← A ⎕PLOT B : Plot a Value</a><tr class=toc_H5><td class=toc_c1>3.4.14.23<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.23>Z ← A ⎕PNG B : Process PNG files and Pixel Images</a><tr class=toc_H5><td class=toc_c1>3.4.14.24<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.24>Z ← A ⎕RE B : Regular expression</a><tr class=toc_H5><td class=toc_c1>3.4.14.25<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.25>Z ← A ⎕RVAL B : Random APL value</a><tr class=toc_H5><td class=toc_c1>3.4.14.26<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.26>Z ← [A] ⎕SI B : State Indicator</a><tr class=toc_H5><td class=toc_c1>3.4.14.27<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.27>Z ← ⎕SQL[CMD] B : SQL functions</a><tr class=toc_H5><td class=toc_c1>3.4.14.28<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.28>Z ← ⎕SVC B : Shared Variable Control</a><tr class=toc_H5><td class=toc_c1>3.4.14.29<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.29>Z ← ⎕SVO B : Shared Variable Offer</a><tr class=toc_H5><td class=toc_c1>3.4.14.30<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.30>Z ← ⎕SVQ B : Shared Variable Query</a><tr class=toc_H5><td class=toc_c1>3.4.14.31<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.31>Z ← ⎕SVR B : Shared Variable Retraction</a><tr class=toc_H5><td class=toc_c1>3.4.14.32<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.32>Z ← ⎕SVS B : Shared Variable State</a><tr class=toc_H5><td class=toc_c1>3.4.14.33<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.33>Z ← [A] ⎕STOP B : STOP vector</a><tr class=toc_H5><td class=toc_c1>3.4.14.34<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.34>Z ← A ⎕TF B : Transfer Form</a><tr class=toc_H5><td class=toc_c1>3.4.14.35<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.35>Z ← ⎕XML B : XML parser</a><tr class=toc_H5><td class=toc_c1>3.4.14.36<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.36>Z ← ⎕TRACE B : TRACE vector</a><tr class=toc_H5><td class=toc_c1>3.4.14.37<td class=toc_c2><a class=toc_a2 href=#CH_3.4.14.37>Z ← ⎕UCS B : Universal Char Set</a><tr class=toc_H3><td class=toc_c1>3.5<td class=toc_c2><a class=toc_a2 href=#CH_3.5>Variables</a><tr class=toc_H4><td class=toc_c1>3.5.1<td class=toc_c2><a class=toc_a2 href=#CH_3.5.1>The Variables ⎕ and ⍞</a><tr class=toc_H5><td class=toc_c1>3.5.1.1<td class=toc_c2><a class=toc_a2 href=#CH_3.5.1.1>Input and Output with ⍞</a><tr class=toc_H5><td class=toc_c1>3.5.1.2<td class=toc_c2><a class=toc_a2 href=#CH_3.5.1.2>Input and Output with ⎕</a><tr class=toc_H5><td class=toc_c1>3.5.1.3<td class=toc_c2><a class=toc_a2 href=#CH_3.5.1.3>⎕ Input in Application Programs</a><tr class=toc_H3><td class=toc_c1>3.6<td class=toc_c2><a class=toc_a2 href=#CH_3.6>Indexing</a><tr class=toc_H3><td class=toc_c1>3.7<td class=toc_c2><a class=toc_a2 href=#CH_3.7>Execution of APL Statements</a><tr class=toc_H3><td class=toc_c1>3.8<td class=toc_c2><a class=toc_a2 href=#CH_3.8>Defined Functions</a><tr class=toc_H4><td class=toc_c1>3.8.1<td class=toc_c2><a class=toc_a2 href=#CH_3.8.1>Function Header</a><tr class=toc_H5><td class=toc_c1>3.8.1.1<td class=toc_c2><a class=toc_a2 href=#CH_3.8.1.1>Creating and displaying defined functions: ⎕FX and ⎕CR</a><tr class=toc_H5><td class=toc_c1>3.8.1.2<td class=toc_c2><a class=toc_a2 href=#CH_3.8.1.2>Result Specification</a><tr class=toc_H5><td class=toc_c1>3.8.1.3<td class=toc_c2><a class=toc_a2 href=#CH_3.8.1.3>Local Variables</a><tr class=toc_H5><td class=toc_c1>3.8.1.4<td class=toc_c2><a class=toc_a2 href=#CH_3.8.1.4>The Del Editor</a><tr class=toc_H5><td class=toc_c1>3.8.1.5<td class=toc_c2><a class=toc_a2 href=#CH_3.8.1.5>Function Body</a><tr class=toc_H4><td class=toc_c1>3.8.2<td class=toc_c2><a class=toc_a2 href=#CH_3.8.2>How Functions and Operators are Evaluated</a><tr class=toc_H4><td class=toc_c1>3.8.3<td class=toc_c2><a class=toc_a2 href=#CH_3.8.3>Branching</a><tr class=toc_H5><td class=toc_c1>3.8.3.1<td class=toc_c2><a class=toc_a2 href=#CH_3.8.3.1>Labels</a><tr class=toc_H5><td class=toc_c1>3.8.3.2<td class=toc_c2><a class=toc_a2 href=#CH_3.8.3.2>Computed Branch (inside a function)</a><tr class=toc_H5><td class=toc_c1>3.8.3.3<td class=toc_c2><a class=toc_a2 href=#CH_3.8.3.3>Computed Branch (outside a function)</a><tr class=toc_H5><td class=toc_c1>3.8.3.4<td class=toc_c2><a class=toc_a2 href=#CH_3.8.3.4>Escape (Unwind)</a><tr class=toc_H2><td class=toc_c1>4<td class=toc_c2><a class=toc_a2 href=#CH_4>Commands</a><tr class=toc_H3><td class=toc_c1>4.1<td class=toc_c2><a class=toc_a2 href=#CH_4.1>Standard Commands</a><tr class=toc_H4><td class=toc_c1>4.1.1<td class=toc_c2><a class=toc_a2 href=#CH_4.1.1>)CLEAR</a><tr class=toc_H4><td class=toc_c1>4.1.2<td class=toc_c2><a class=toc_a2 href=#CH_4.1.2>)COPY</a><tr class=toc_H4><td class=toc_c1>4.1.3<td class=toc_c2><a class=toc_a2 href=#CH_4.1.3>)COPY_ONCE</a><tr class=toc_H4><td class=toc_c1>4.1.4<td class=toc_c2><a class=toc_a2 href=#CH_4.1.4>)DROP</a><tr class=toc_H4><td class=toc_c1>4.1.5<td class=toc_c2><a class=toc_a2 href=#CH_4.1.5>)ERASE</a><tr class=toc_H4><td class=toc_c1>4.1.6<td class=toc_c2><a class=toc_a2 href=#CH_4.1.6>)FNS</a><tr class=toc_H4><td class=toc_c1>4.1.7<td class=toc_c2><a class=toc_a2 href=#CH_4.1.7>)LIB</a><tr class=toc_H4><td class=toc_c1>4.1.8<td class=toc_c2><a class=toc_a2 href=#CH_4.1.8>)LOAD</a><tr class=toc_H4><td class=toc_c1>4.1.9<td class=toc_c2><a class=toc_a2 href=#CH_4.1.9>)NMS</a><tr class=toc_H4><td class=toc_c1>4.1.10<td class=toc_c2><a class=toc_a2 href=#CH_4.1.10>)OPS</a><tr class=toc_H4><td class=toc_c1>4.1.11<td class=toc_c2><a class=toc_a2 href=#CH_4.1.11>)SAVE</a><tr class=toc_H4><td class=toc_c1>4.1.12<td class=toc_c2><a class=toc_a2 href=#CH_4.1.12>)SI</a><tr class=toc_H4><td class=toc_c1>4.1.13<td class=toc_c2><a class=toc_a2 href=#CH_4.1.13>)SIC</a><tr class=toc_H4><td class=toc_c1>4.1.14<td class=toc_c2><a class=toc_a2 href=#CH_4.1.14>)SINL</a><tr class=toc_H4><td class=toc_c1>4.1.15<td class=toc_c2><a class=toc_a2 href=#CH_4.1.15>)SIS</a><tr class=toc_H4><td class=toc_c1>4.1.16<td class=toc_c2><a class=toc_a2 href=#CH_4.1.16>)VARS</a><tr class=toc_H4><td class=toc_c1>4.1.17<td class=toc_c2><a class=toc_a2 href=#CH_4.1.17>)WSID</a><tr class=toc_H3><td class=toc_c1>4.2<td class=toc_c2><a class=toc_a2 href=#CH_4.2>IBM APL2 Commands</a><tr class=toc_H4><td class=toc_c1>4.2.1<td class=toc_c2><a class=toc_a2 href=#CH_4.2.1>)CHECK</a><tr class=toc_H4><td class=toc_c1>4.2.2<td class=toc_c2><a class=toc_a2 href=#CH_4.2.2>)CONTINUE</a><tr class=toc_H4><td class=toc_c1>4.2.3<td class=toc_c2><a class=toc_a2 href=#CH_4.2.3>)HELP</a><tr class=toc_H4><td class=toc_c1>4.2.4<td class=toc_c2><a class=toc_a2 href=#CH_4.2.4>)HOST</a><tr class=toc_H4><td class=toc_c1>4.2.5<td class=toc_c2><a class=toc_a2 href=#CH_4.2.5>)IN</a><tr class=toc_H4><td class=toc_c1>4.2.6<td class=toc_c2><a class=toc_a2 href=#CH_4.2.6>)MORE</a><tr class=toc_H4><td class=toc_c1>4.2.7<td class=toc_c2><a class=toc_a2 href=#CH_4.2.7>)OUT</a><tr class=toc_H4><td class=toc_c1>4.2.8<td class=toc_c2><a class=toc_a2 href=#CH_4.2.8>)OFF</a><tr class=toc_H4><td class=toc_c1>4.2.9<td class=toc_c2><a class=toc_a2 href=#CH_4.2.9>)PCOPY</a><tr class=toc_H4><td class=toc_c1>4.2.10<td class=toc_c2><a class=toc_a2 href=#CH_4.2.10>)PIN</a><tr class=toc_H4><td class=toc_c1>4.2.11<td class=toc_c2><a class=toc_a2 href=#CH_4.2.11>)RESET</a><tr class=toc_H4><td class=toc_c1>4.2.12<td class=toc_c2><a class=toc_a2 href=#CH_4.2.12>)SYMBOLS</a><tr class=toc_H3><td class=toc_c1>4.3<td class=toc_c2><a class=toc_a2 href=#CH_4.3>Additional GNU APL Commands</a><tr class=toc_H4><td class=toc_c1>4.3.1<td class=toc_c2><a class=toc_a2 href=#CH_4.3.1>)DUMP</a><tr class=toc_H4><td class=toc_c1>4.3.2<td class=toc_c2><a class=toc_a2 href=#CH_4.3.2>)DUMP-HTML</a><tr class=toc_H4><td class=toc_c1>4.3.3<td class=toc_c2><a class=toc_a2 href=#CH_4.3.3>)HIST</a><tr class=toc_H4><td class=toc_c1>4.3.4<td class=toc_c2><a class=toc_a2 href=#CH_4.3.4>)LIBS</a><tr class=toc_H4><td class=toc_c1>4.3.5<td class=toc_c2><a class=toc_a2 href=#CH_4.3.5>)QLOAD</a><tr class=toc_H4><td class=toc_c1>4.3.6<td class=toc_c2><a class=toc_a2 href=#CH_4.3.6>)VALUES</a><tr class=toc_H4><td class=toc_c1>4.3.7<td class=toc_c2><a class=toc_a2 href=#CH_4.3.7>]BOXING</a><tr class=toc_H4><td class=toc_c1>4.3.8<td class=toc_c2><a class=toc_a2 href=#CH_4.3.8>]COLOR</a><tr class=toc_H4><td class=toc_c1>4.3.9<td class=toc_c2><a class=toc_a2 href=#CH_4.3.9>]DOXY</a><tr class=toc_H4><td class=toc_c1>4.3.10<td class=toc_c2><a class=toc_a2 href=#CH_4.3.10>]EXPECT</a><tr class=toc_H4><td class=toc_c1>4.3.11<td class=toc_c2><a class=toc_a2 href=#CH_4.3.11>]KEYB</a><tr class=toc_H4><td class=toc_c1>4.3.12<td class=toc_c2><a class=toc_a2 href=#CH_4.3.12>]LOG</a><tr class=toc_H4><td class=toc_c1>4.3.13<td class=toc_c2><a class=toc_a2 href=#CH_4.3.13>]NEXTFILE</a><tr class=toc_H4><td class=toc_c1>4.3.14<td class=toc_c2><a class=toc_a2 href=#CH_4.3.14>]OWNERS</a><tr class=toc_H4><td class=toc_c1>4.3.15<td class=toc_c2><a class=toc_a2 href=#CH_4.3.15>]SVARS</a><tr class=toc_H4><td class=toc_c1>4.3.16<td class=toc_c2><a class=toc_a2 href=#CH_4.3.16>]SYMBOL</a><tr class=toc_H4><td class=toc_c1>4.3.17<td class=toc_c2><a class=toc_a2 href=#CH_4.3.17>]USERCMD</a><tr class=toc_H4><td class=toc_c1>4.3.18<td class=toc_c2><a class=toc_a2 href=#CH_4.3.18>]XTERM</a></table><hr><h1>A Quick Tour of GNU APL</h1><p>June 29, 2024, SVN version 1776M</p><br>Please report errors in this document to <a href=mailto:bug-apl@gnu.org>bug-apl@gnu.org</a><br><br>Copyright (©) 2013-2024 Dr. Jürgen Sauermann and friends.<br>This document is part of GNU APL and may be distributed under the terms of<br>the GNU Free Documentation License, see
<a href=http://www.gnu.org/licenses/fdl.html>http://www.gnu.org/licenses/fdl.html</a><br><br><h2><a id=CH_1></a>1 Document Conventions</h2><h3><a id=CH_1.1></a>1.1 The Structure of the GNU APL Documentation</h3>GNU APL is shipped with different kinds of documentation for different
purposes to be used at different times:<ol><li>A number of <b>README</b> files in the top-level directory. These files
shall help with specific issues in the configuration of the interpreter,
i.e. before the interpreter is compiled and/or after it is installed.<li><b>man apl</b> (in a terminal window) displays a list of all command line
options understood by GNU APL.<li>The <b>)HELP</b> command of the interpreter:<ul><li>)HELP without an argument prints a list of APL commands,
APL system functions, and APL system variables known by
the interpreter,<li><b>)HELP primitive</b> shows a more detailed help for the given
primitive (if such help is available).</ul><li>This document (Quick Tour). It is a little more detailed, with a focus
on examples. This is supposedly the best starting point for readers
that are new to APL in general or to GNU APL in particular.<li><b>info apl</b> (in a terminal window). More detailed with a focus on only
GNU APL specific features that are not available in, or differ from,
standard APL.<li>A number of files in the <b>HOWTOs</b> directory. These files describe
some of the non-trivial GNU APL system functions.</ol>All documentation is available on the local machine after GNU APL
was successfully installed, and some of it is also available online
via the GNU APL home page <a href=https://www.gnu.org/software/apl>https://www.gnu.org/software/apl</a>.<h3><a id=CH_1.2></a>1.2 Conventions in This Document</h3>Keyboard input is rendered in <span style=color:blue><b>blue</b></span>
and the response from the GNU APL interpreter is <b>black</b> like this:<pre class=input_T line=868>      This is what you type on the keyboard</pre><pre class=output1 line=908>and this is the response you get for correct input

</pre><pre class=input_ line=665>      1+    ⍝ In contrast, APL ERROR messages are shown in red:</pre><pre class=errput line=742>SYNTAX ERROR
      1+
      ^^
</pre>Error messages from the interpreter are shown in
<span style=color:red><b>red</b></span>. This coloring of input, output,
and error lines above is the default, but it is possible to change the
colors, or (e.g. if GNU APL is run as a script) to disable the
colorization completely.<h2><a id=CH_2></a>2 Starting and stopping the APL interpreter</h2>APL is an easy-to-learn language. This quick start manual is an introduction
to APL in a few simple steps. We assume that you are using GNU APL and that
you have installed it according to the README files that came with it.<br><br>The APL interpreter is a normal program and is started like that: by entering
its name in a shell (preferably <b>bash</b>).<br><pre class=input_T line=868>$ apl</pre><pre class=output line=908>                    ______ _   __ __  __    ___     ____   __
                   / ____// | / // / / /   /   |   / __ \ / /
                  / / __ /  |/ // / / /   / /| |  / /_/ // /
                 / /_/ // /|  // /_/ /   / ___ | / ____// /___
                 \____//_/ |_/ \____/   /_/  |_|/_/    /_____/

                        Welcome to GNU APL version 1.8

                Copyright (C) 2008-2022  Dr. Jürgen Sauermann
                       Banner by FIGlet: www.figlet.org

                This program comes with ABSOLUTELY NO WARRANTY;
                         for details run: ./apl --gpl.

     This program is free software, and you are welcome to redistribute it
         according to the GNU Public License (GPL) version 3 or later.



</pre>The interpreter prints a start-up banner like that shown above and then enters
an endless loop which APL programmers refer to as <b>immediate execution mode</b>
and others as <b>REPL</b> (an abbreviation for
<b>R</b>ead-<b>E</b>valuate-<b>P</b>rint-<b>L</b>oop).<br><br>In immediate execution mode the interpreter reads one input line, either
interactively from the user, or from a file if GNU APL is run as a script.
It then processes (or <b>E</b>valuates in <b>REPL</b>) the input line and
prints some result output (which may be empty for some input lines).
Depending on the details of the processing of the line entered, the
interpreter will either:<ul><li>remain in immediate execution mode (the <b>L</b>oop in <b>REPL</b>), or<li>enter another mode called definition mode, or<li>exit the interpreter</ul>The following state machine describes this top-level behavior of an APL
interpreter, and some user inputs that trigger mode changes:<pre>
                                ┌───────┐
                                │ Start │
                                └───────┘
                                    ↓
                                    ↓
                   ╔═══════════════════════════════╗      )OFF      ┌──────┐
         → → → → → ║   Immediate Execution Mode    ║→ → → → → → → → │ EXIT │
        ↑          ║        (Read in REPL)         ║                └──────┘
        ↑          ╚═══════════════════════════════╝
        ↑             ↓        ↑    ↑           ↓
        ↑             ↓       ^C    ↑           ∇ (enter definition mode)
        ↑             ↓        ↑    ↑           ↓
        ↑   ╔════════════════════╗  ↑  ╔═════════════════╗
        ↑   ║   Execution Mode   ║  ↑  ║ Definition Mode ║
        ↑   ║ (Evaluate in REPL) ║  ↑  ║   (∇-editor)    ║
        ↑   ╟────────────────────╢  ↑  ╚═════════════════╝
        ↑   ║  (Print in REPL)   ║  ↑           ↓
        ↑   ╚════════════════════╝  ↓           ∇ (leave definition mode)
        ↑             ↓             ↓           ↓
         ← ← ← ← ← ← ←               ← ← ← ← ← ←
   </pre>In the first case, i.e. the interpreter remains in immediate execution mode,
the whole process starts over again; the next line is read, processed, printed,
and so on.
The second case (leaving immediate execution mode) is explained in a later
chapter.
The first non-blank character of the line entered in immediate execution mode
determines what happens next:<ul><li>if the first non-blank character is either <b>)</b> or <b>]</b> then the
line is interpreted and processed as an APL command. Commands are
discussed in chapter "Commands" below. Commands that start with <b>]</b>
instead of <b>)</b> are a GNU APL extension of standard APL.<br><li>if the first non-blank character is <b>∇</b> then an APL function editor
(the ∇-editor) is started and editing of a new or already existing
user-defined function begins until ∇ is typed again. User-defined
functions are simply called <b>defined function</b>s in APL jargon.
The construction and editing of defined functions is discussed in chapter
<b>Defined Functions</b> below.<br><li>Otherwise the line is considered a sequence of APL statements and the
interpreter enters <b>execution mode</b> (which corresponds to the
<b>E</b>valuate in <b>REPL</b>) in which APL code is being executed.
The execution mode may have its own loops which may be interrupted
with ^C. The execution mode is left automatically after the last APL
statement was processed, or after an APL error had occurred. APL
statements are discussed in chapter "APL Statements" below.</ul>The most important command at the moment is <b>)OFF</b> which ends the
apl interpreter:<pre class=input_T line=868>      )OFF</pre><pre class=output line=908>Goodbye.
$</pre>Pressing control-C or control-D (i.e. the standard way to end programs)
merely stops the execution of the current APL statement in execution mode,
but does not end the interpreter. This behavior is similar to a shell where
control-C stops the current program but does not exit from the shell.<h2><a id=CH_3></a>3 APL Statements</h2>APL statements are constructed from:<ul><li>APL constants (numbers and characters)<li>Names (of functions and/or variables)<li>other characters (APL glyphs) e.g.: ← → [ ; ] + ◊ ÷ ( ) or :</ul>Several statements on the same line are separated by the APL character ◊
(called <i>Diamond</i>). Note that different statements on the same line are
executed from left to right while each statement is evaluated from right
to left. Before discussing the execution of statements we will introduce
their components, i.e. constants and names.<h3><a id=CH_3.1></a>3.1 Constants (Literals)</h3>Constants, also called <i>literals</i>, are used in APL statements for denoting
fixed values.<h4><a id=CH_3.1.1></a>3.1.1 Scalar Constants</h4>The simplest constants are scalar constants, similar to atoms in Chemistry.
From these scalar constants more complex constants can be created. There are
also scalar APL values which are not constants; a definition of the term
scalar will be given later. For the moment think of a scalar as a single
data item.<h5><a id=CH_3.1.1.1></a>3.1.1.1 Scalar Text Constants</h5>The simplest scalar constants are scalar text constants. A scalar text
constant defines a single character.<br>As we will discuss in more detail later, if you enter a constant
(and nothing else) in immediate execution mode then the interpreter will
transmit it to its output, although in a slightly different fashion.<br>A scalar text constant (aka. a single character) is entered by enclosing the
character in single quotes. The character A, for example, is entered as 'A'
and the interpreter answers by printing A but removing the quotes around it:<pre class=input_T line=664>      'A'</pre><pre class=output line=731>A
</pre>The quote character itself is entered by doubling it inside the quotes
that enclose it:<pre class=input_T line=664>      ''''</pre><pre class=output line=731>'
</pre><h5><a id=CH_3.1.1.2></a>3.1.1.2 Numeric Scalar Constants</h5>A numeric scalar constant is a single number. The simplest numeric scalar
constant is an integer, entered as a sequence of decimal digits:<pre class=input_T line=664>      42</pre><pre class=output line=731>42
</pre>Fractional numbers are entered with a decimal point and a fractional part:<pre class=input_T line=664>      42.5</pre><pre class=output line=731>42.5
</pre>The integral part can be omitted:<pre class=input_T line=664>      .5</pre><pre class=output line=731>0.5
</pre>An optional scaling by a power of 10 (aka. scientific notation) can be applied
with the character E, followed by the exponent. The E is case insensitive,
therefore e will also work:<pre class=input_T line=664>      42.5E3</pre><pre class=output1 line=732>42500
</pre><pre class=input_ line=665>      42e3</pre><pre class=output line=731>42000
</pre>Negative numbers use a leading ¯ (Overbar); a minus sign is NOT the sign of
a number but a function that negates a value. The result is often the same,
but you should always use the overbar for negative numbers:<pre class=input_T line=664>      ¯42.5E3</pre><pre class=output line=731>¯42500
</pre>The exponent in scientific notation can also be negative (in this case using
- gives a different result):<pre class=input_T line=664>      42.5E¯3</pre><pre class=output1 line=732>0.0425
</pre><pre class=input_ line=665>      42.5E-3</pre><pre class=errput line=742>VALUE ERROR
      42.5 E-3
           ^
</pre>The error in the second statement above occurs because:<ol><li>in APL the minus sign (i.e. - as opposed to ¯) is a primitive function and
never part of a number, and therefore<li>the <b>E</b> is not an exponent belonging to 42.5. Instead <b>E</b> is taken
as the name of a variable (which does not exist in this example) and that
causes the error. Using - instead of ¯ is a frequent mistake made by APL
beginners.</ol>Complex numbers can be entered in three different formats. The native format
(native because it is the format used by the interpreter when printing
complex numbers) is to specify the real and imaginary parts of a complex
number separated by the letter J (or j):<pre class=input_T line=664>      3J4       ⍝ a complex number of magnitude 5</pre><pre class=output1 line=732>3J4
</pre><pre class=input_ line=665>      0.6j0.8   ⍝ the same, but scaled to magnitude 1</pre><pre class=output line=731>0.6J0.8
</pre>One alternative format is to specify the number as its magnitude and its
angle in degrees (from 0° to 360°), separated by the letter D or d (which
stands for "degrees"). Since arccos(0.6) = 53.130102354, we get the
same complex numbers:<pre class=input_T line=664>      5D53.130102354   ⍝ magnitude 5, angle 53.130102354°</pre><pre class=output1 line=732>3J4
</pre><pre class=input_ line=665>      1d53.130102354   ⍝ the same, but scaled to magnitude 1</pre><pre class=output line=731>0.6J0.8
</pre>The other alternative format is to specify the number as its magnitude and its
angle in radians (from 0 to 2π), separated by the letter R or r (for
"radians"). Since 53.130102354 π ÷ 180 = 0.927295218 we get the same numbers:<pre class=input_T line=664>      5R0.927295218   ⍝ magnitude 5, angle 0.927295218 radians</pre><pre class=output1 line=732>3J4
</pre><pre class=input_ line=665>      1r0.927295218   ⍝ the same, but scaled to magnitude 1</pre><pre class=output line=731>0.6J0.8
</pre>Please keep in mind that whitespace characters (space, tab, etc.) are NOT
permitted in numbers.<h4><a id=CH_3.1.2></a>3.1.2 Vector Constants</h4>Vector constants are created by writing several scalar constants on the
same line, separated by one or more spaces between them. A single complex
number is a scalar even if has two components (its real and imaginary parts).
Multiple separating spaces between scalars are treated like single spaces:<pre class=input_T line=664>      1   2 3</pre><pre class=output1 line=732>1 2 3
</pre><pre class=input_ line=665>      'A' 'B' 'C'</pre><pre class=output line=731>ABC
</pre>Sequences of character scalars can be written with quotes around the sequence
rather than quotes around each character. The rules for scalar character
constants apply here as well:<pre class=input_T line=664>      'ABC'</pre><pre class=output1 line=732>ABC
</pre><pre class=input_ line=665>      'A''B''C'</pre><pre class=output1 line=732>A'B'C
</pre><pre class=input_ line=665>      "A'B'C"</pre><pre class=output line=731>A'B'C
</pre>You cannot enter numeric vector constants with less than two elements because
numeric vector constants with one element would be a numeric scalar constant,
and numeric vector constants with no elements would be completely empty.
You can enter an empty character vector constant (a vector with no elements)
like this:<pre class=input_T line=664>      ''</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      ""</pre><pre class=output line=719>
</pre>You normally cannot enter character vector constants with one element for
the same reason as for numeric vector constants: it would be a scalar
constant rather than a vector. This can become cumbersome when dealing with
text; if the length of a character sequence is one then the text is a scalar,
otherwise it is a vector. For this reason GNU APL provides a non-standard
extension using double quotes instead of single quotes. This extension has
slightly different and sometimes more convenient rules than texts in single
quotes:<ul><li>double quoted characters are always vectors (even if their length is 1)<li>single quotes stand for themselves and need not be doubled<li>for some problematic characters C-like sequences are defined:<ul><li><b>\0</b> produces <b>NUL</b> (null, ASCII code 0)<li><b>\a</b> produces <b>BEL</b> (bell, ASCII code 7)<li><b>\b</b> produces <b>BS</b> (backspace, ASCII code 8)<li><b>\t</b> produces <b>TAB</b> (tab, ASCII code 9)<li><b>\n</b> produces <b>NL</b> (newline, ASCII code 10)<li><b>\v</b> produces <b>VT</b> (vertical tab, ASCII code 11)<li><b>\f</b> produces <b>FF</b> (form feed, ASCII code 12)<li><b>\r</b> produces <b>CR</b> (carriage return, ASCII code 13)<li><b>\[</b> produces <b>ESC</b> (escape, ASCII code 27)<li><b>\"</b> produces <b>"</b> (double quote, ASCII code 34)<li><b>\\</b> produces <b>\</b> (backslash, ASCII code 92)</ul></ul>Examples:<pre class=input_T line=664>      "A"   ⍝ 1-element vector</pre><pre class=output1 line=732>A
</pre><pre class=input_ line=665>      "'"   ⍝ a quote (')</pre><pre class=output1 line=732>'
</pre><pre class=input_ line=665>      "A\"B\\C"   ⍝ 'A', double quote, 'B', backslash, 'C'</pre><pre class=output line=731>A"B\C
</pre>Finally, in the old APL1 (ISO 8485 standard) there was no way to express
an empty numeric vector and one had to use expressions like <b>⍳0</b> or
<b>0⍴0</b> for them. In modern interpreters, however, the symbol <b>⍬</b> may
be used to denote an empty numeric vector (i.e. of length 0). In APL1 empty
numeric vectors were often expressed as '', frequently as ''⍴V to get the
first item of a vector or matrix into a scalar. That worked, but these days
one would use the cleaner <b>⍬⍴V</b> instead.<h4><a id=CH_3.1.3></a>3.1.3 Mixed Constants</h4>The first APL interpreters (and the first APL standard, ISO 8485) only allowed
constants and values whose components were either all numeric scalars, or all
character scalars. The examples given so far were of that kind.
The current APL standard, ISO 13751, also allows a mix of characters and
numbers in constants and values, for example:<pre class=input_T line=664>      1 2 'A' 'B' 3 4</pre><pre class=output line=731>1 2 AB 3 4
</pre>Such values are called <b>mixed</b>.<h4><a id=CH_3.1.4></a>3.1.4 Nested Constants</h4>The vector constants discussed so far were <b>simple</b>, which means that their
components were (numeric or character) scalars. Since ISO 13751, another
APL value can be used instead of a scalar. Such constants or values are called
<b>nested</b>. The nested components of constants are vectors that are
either quoted texts (aka. <b>strings</b>) or, if numeric, surrounded by
parentheses instead of quotes:<pre class=input_T line=664>      1 2 'AB' 3 4   ⍝ (nested) string 'AB'</pre><pre class=output1 line=732> 1 2 AB 3 4
</pre><pre class=input_ line=665>      1 2 (10 11) 3 4     ⍝ nested numeric vector (10 11)</pre><pre class=output line=731> 1 2  10 11  3 4
</pre>In the normal output formatting of APL like above, the nesting of items is
displayed as additional blanks which makes it sometimes difficult to recognize
the exact nesting structure. The quotes and parentheses that group the items
of a nested literal on input are replaced by blanks on output. That blurs
the output, in particular when the nesting becomes deeper (i.e. when a nested
value contains nested items). Nested values differ from non-nested values
comprised of the same scalars only by the number spaces between the scalars,
which is difficult to see if the values are long or deeply nested.
For that reason, APL interpreters often come with functions, either built-in
or defined functions that display the structure of nested values in a clearer
way. In IBM APL2 these functions are called DISPLAY and DISPLAYC (in workspace
DISPLAY, the two functions slightly differ in style). In GNU APL the functions
are built-in and are several subfunctions of dyadic ⎕CR (e.g. 4 ⎕CR and 8 ⎕CR,
also slightly differing in style). In GNU APL, ⎕CR is a collection of more
than 40 subfunctions, some of which play the roles of <b>DISPLAY</b> in IBM APL2.
For example:<pre class=input_T line=664>      1 2 'AB' 3 4       ⍝ standard output formatting</pre><pre class=output1 line=732> 1 2 AB 3 4
</pre><pre class=input_ line=665>      4 ⎕CR 1 2 'AB' 3 4      ⍝ same value in 4⎕CR style</pre><pre class=output1 line=732>┏→━━━━━━━━━━━┓
┃1 2 ┏→━┓ 3 4┃
┃    ┃AB┃    ┃
┃    ┗━━┛    ┃
┗ϵ━━━━━━━━━━━┛
</pre><pre class=input_ line=665>      8 ⎕CR 1 2 'AB' 3 4      ⍝ same value in 8⎕CR style</pre><pre class=output1 line=732>┌→───────────┐
│1 2 ┌→─┐ 3 4│
│    │AB│    │
│    └──┘    │
└ϵ───────────┘
</pre><pre class=input_ line=665>      1 2 (10 11) 3 4         ⍝ standard output formatting</pre><pre class=output1 line=732> 1 2  10 11  3 4
</pre><pre class=input_ line=665>      4 ⎕CR 1 2 (10 11) 3 4   ⍝ same value in 4⎕CR style</pre><pre class=output1 line=732>┏→━━━━━━━━━━━━━━┓
┃1 2 ┏→━━━━┓ 3 4┃
┃    ┃10 11┃    ┃
┃    ┗━━━━━┛    ┃
┗ϵ━━━━━━━━━━━━━━┛
</pre><pre class=input_ line=665>      8 ⎕CR 1 2 (10 11) 3 4   ⍝ same value in 8⎕CR style</pre><pre class=output line=731>┌→──────────────┐
│1 2 ┌→────┐ 3 4│
│    │10 11│    │
│    └─────┘    │
└ϵ──────────────┘
</pre>Some users prefer that APL output is always displayed in the format of 8 ⎕CR
(or in one of the other styles that ⎕CR provides). This can be achived by a
GNU APL command:<pre class=input_T line=664>      1 2 'AB' 3 4   ⍝ by default: standard output formatting</pre><pre class=output1 line=732> 1 2 AB 3 4
</pre><pre class=input_ line=665>      ⍝ display results automatically in 8 ⎕CR format</pre><pre class=input_ line=665>      ]BOXING 8</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      1 2 'AB' 3 4</pre><pre class=output1 line=732>┌→───────────┐
│1 2 ┌→─┐ 3 4│
│    │AB│    │
│    └──┘    │
└ϵ───────────┘
</pre><pre class=input_ line=665>      ⍝ back to the standard format</pre><pre class=input_ line=665>      ]BOXING OFF</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      1 2 'AB' 3 4</pre><pre class=output1 line=732> 1 2 AB 3 4
</pre><pre class=output line=908></pre><h4><a id=CH_3.1.5></a>3.1.5 Multi-Line Strings</h4>In APL1 text with several lines would normally be expressed as a two
dimensional character matrix:<pre class=input_T line=664>      3 5⍴"Peter", "Paul ", "Mary "   ⍝ 3-line APL1 text matrix</pre><pre class=output line=731>Peter
Paul
Mary
</pre>That approach becomes rather cumbersome and inefficient when the number
of text rows is large (a single long line would "blow up" the other lines
to its length, yielding a larger than necessary matrix that consist mostly
of trailing spaces). In the days of APL1 that was sort of acceptable
because the focus was more on numerical computations rather than text
processing and the rare texts were mostly used as short decorators
for the numbers displayed.
Things have changed since then and with the advent of nested values in APL2
one would express long texts as a vector of nested strings rather than as
character matrices:<pre class=input_T line=664>      "Peter" "Paul" "Mary"   ⍝ nested 3-item APL2 vector (note the lack of trailing input spaces and the output indentation)</pre><pre class=output1 line=732> Peter Paul Mary
</pre><pre class=input_ line=665>      ⊃ "Peter" "Paul" "Mary"   ⍝ back to APL1 text matrix (not indented)</pre><pre class=output line=731>Peter
Paul
Mary
</pre>Even though this improves over APL1, it is still cumbersome if the number
of lines is large or not known beforehand. In that case one often finds,
even in APL2, constructs like:<pre class=input_T line=664>      TEXT←3⍴0      ⍝ reserve space for 3 (nested) lines</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      TEXT[1]←⊂'Peter'   ⍝ ⊂ turns text vector 'Peter' into a nested scalar</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      TEXT[2]←⊂'Paul'</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      TEXT[3]←⊂'Mary'</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      ⊃ TEXT</pre><pre class=output line=731>Peter
Paul
Mary
</pre>Or, even worse (since the execution time increases quadratically with the
number of lines):<pre class=input_T line=664>      TEXT←⍬        ⍝ start with an empty vector</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      TEXT ← TEXT, ⊂'Peter'   ⍝ append line 'Peter'</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      TEXT ← TEXT, ⊂'Paul'    ⍝ append line 'Paul' (no trailing space needed)</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      TEXT ← TEXT, ⊂'Mary'    ⍝ append line 'Mary' (no trailing space needed)</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      ⊃ TEXT</pre><pre class=output line=731>Peter
Paul
Mary
</pre>To further improve and simplify the specification of multi-line texts, which
is a problem that often occurs in real life APL programs, GNU APL has adopted
the concept of multi-line strings from the Python language or from
the bash shell. A multi-line string starts and ends with triple quotes
and the lines between become a nested text vector:<pre class=input_T line=868>      TEXT ←  """
→      Peter
→      Paul
→      Mary
→            """
      8 ⎕CR TEXT</pre><pre class=output line=908>┌→────────────────────┐
│┌→────┐ ┌→───┐ ┌→───┐│
││Peter│ │Paul│ │Mary││
│└─────┘ └────┘ └────┘│
└ϵ────────────────────┘</pre><pre class=input_T line=664>      ⊃ TEXT</pre><pre class=output line=731>Peter
Paul
Mary
</pre>Note the → prompt (from APL), which indicates that a multi-line string has
started but not yet ended. The characters in the triple quotes shall be either
" or else (double angle quotes) « in the leading and » in the
trailing triple quotes (the same holds, BTW also for normal GNU APL strings.
Intelligent editors are able to jump back and forth between matching quotes,
but only if the leading quote differs from the trailing quote. Use this
capability with care, since it undermines the portability of APL code written
for GNU APL.<h4><a id=CH_3.1.6></a>3.1.6 Summary and Remarks</h4>Constants are used for creating fixed APL values. There are many APL values
that cannot be expressed by constants, for example numeric vectors with only
one component, or higher-dimensional values like matrices. These values
can only be created using functions (as explained further down).<h3><a id=CH_3.2></a>3.2 APL Names</h3>APL knows 3 kinds of names:<ul><li>user defined names,<li>names of system functions and variables, and<li>names of primitive APL functions (or primitives for short)</ul><h4><a id=CH_3.2.1></a>3.2.1 User-defined Names</h4>User-defined names start with a letter (A-Z or a-z) or one of the 3 characters
_ (underscore), ∆ (delta), or ⍙ (delta-underline. The starting
character may be followed by letters, digits, or one of the characters
¯ (overbar), _, ∆, or ⍙. The ∆ and ⍙ characters are often used to separate
some common prefix (for example the name of a library) from the functions
and variables that are somehow related (for example the functions and
variables that belong to a library). User-defined Names are case-sensitive,
i.e. <b>Foo</b> and <b>FOO</b> are different names.
User-defined names are used to denote APL variables, defined functions,
defined operators, or labels in defined functions or operators.<h4><a id=CH_3.2.2></a>3.2.2 Names of System Functions and System Variables</h4>The names of system functions start with the APL character ⎕ (quad) followed by
a small number of letters. System names are case-insensitive, i.e. <b>⎕IO</b> is
the same as <b>⎕io</b>. Older APL programmers seem to prefer uppercase,
presumably because the first APL interpreters had no lowercase characters.
Only a handful of system functions and variables are standardized in the ISO
standards 8485 and 13751, but every APL interpreter adds many more. Those that
are not defined in the standards differ considerably between APL interpreters
from different vendors even if their names are the same. Adding non-standard
system functions and variables are the normal way of adding features to the
APL language; they usually add functions whose implementation in APL would
be inefficient or cumbersome.<h4><a id=CH_3.2.3></a>3.2.3 Names of Primitive APL Functions</h4>The names of primitive functions are single APL characters that differ from
all characters allowed in user-defined names.
Almost all the primitive APL functions (and hence their names) are
identical in all APL interpreters and are standardized in ISO standard 13751.
Apart from the differences mentioned above, there is no real difference
between system functions and primitive APL functions.<h3><a id=CH_3.3></a>3.3 Functions and Operators</h3>Functions in APL can have none, one, or two arguments.
Those with no argument are called <b>niladic</b>, functions with one argument
are called <b>monadic</b>, and two-argument functions are called <b>dyadic</b>.
Some monadic or dyadic functions can have another, optional, argument used for
specifying an axis (a dimension along which the function is computed). In
standard APL, only primitive APL functions can have an axis argument, but
GNU APL also supports an axis argument for defined functions.
Most dyadic functions can also be called with only one argument. These functions
are called <b>nomadic</b>. This basically means that the same function name is
used for two different functions. The two functions are often related. For
example, ÷ is nomadic; its dyadic variant A ÷ B (called divide) divides A by B
while its monadic variant (called inverse) divides 1 by B. Another way of
putting this is: a nomadic function is a dyadic function whose left argument
is optional (and omitting it changes its behavior).<h4><a id=CH_3.3.1></a>3.3.1 Niladic Functions</h4>A niladic function takes no arguments. A niladic function call is simply the
name of the niladic function. For example, ⎕TS is a niladic system function
that returns the current time as year, month, day, hours, minutes, seconds,
and milliseconds:<pre class=input_T line=664>      ⎕TS</pre><pre class=output line=731>2024 6 29 14 4 44 229
</pre><h4><a id=CH_3.3.2></a>3.3.2 Monadic Functions</h4>A <b>monadic function</b> takes one argument. A monadic function call consists
of the name of the function followed by its sole argument. For example, the
monadic variant of the nomadic function ÷ computes the inverse of its argument:<pre class=input_T line=664>      ÷ 2</pre><pre class=output1 line=732>0.5
</pre><pre class=input_ line=665>      ÷ 2J2</pre><pre class=output line=731>0.25J¯0.25
</pre>If the optional axis argument mentioned above is supported, then it is
placed in brackets immediately to the right of the function name.<h4><a id=CH_3.3.3></a>3.3.3 Dyadic Functions</h4>A <b>dyadic function</b> takes two arguments. A dyadic function call consists
of the second (aka. left) argument, followed by the name of the function,
followed by its other (aka. right) argument. For example, the
dyadic variant of the nomadic function ÷ computes the left argument divided
by the right argument:<pre class=input_T line=664>      4 ÷ 2</pre><pre class=output1 line=732>2
</pre><pre class=input_ line=665>      4J4 ÷ 2J2</pre><pre class=output line=731>2
</pre>As the last example above shows, APL automatically converts numbers to their
simplest form, i.e. from complex to real, from floating point to integer,
and from integer to Boolean. At least it looks like that. A value that
is, for example, printed like an integer may internally still be a real
or even a complex number.
In older APL interpreters there used to be a function ⎕DR (data representation)
that would tell if an APL value was complex, real, integer, or Boolean.
For mixed arrays introduced by ISO 13751 that does not make much sense
anymore so the ⎕DR function has disappeared.<h4><a id=CH_3.3.4></a>3.3.4 Monadic Operators</h4>APL operators are functions that have one or two value arguments like monadic
or dyadic functions, but in addition take one or two function arguments.
The attribute <b>monadic</b> or <b>dyadic</b> of an operator refers to the
number of function arguments for the operator and not to the number of value
arguments. If <b>OP1</b> is a monadic operator then <b>(f OP1)</b> is a so-called
<b>derived function</b>; depending on the operator its derived function can
be monadic or dyadic.<br><br>A <b>monadic operator</b> is therefore an operator that has one function argument,
and a <b>dyadic operator</b> is an operator that has two function arguments.
As far as built-in APL operators are concerned, one of them (the inner/outer
matrix product . ) is dyadic and all others are monadic.
A monadic operator, together with its function, defines a new function: the
<b>derived function</b>. Likewise, a dyadic operator, together with both
its functions, defines a derived function of that operator. Derived functions
of the same operator but with different function arguments are, of course,
different but they are either all monadic functions or all dyadic functions.<br><br>We take presumably the most frequently used operator, <b>reduction</b>, as an
example. The APL symbol for the reduction operator is / (slash). The function
argument of a monadic operator is the function immediately left of the operator
symbol. The reduction operator is monadic (taking one function argument),
the function provided as its function argument must be dyadic, and the derived
function is monadic. The derived function of reduction with function argument
f is also called f-reduction.<br><br>When the value argument of f-reduction is a vector, then f-reduction computes
the result of placing f between the vector elements:<br><br>f-reduction v1 v2 ... vn ↔ v1 f v2 f ... vn<br><br>If function f is + (addition) then f-reduction of a vector is the sum of
its elements:<pre class=input_T line=664>      +/1 2 3 4 5 6</pre><pre class=output line=731>21
</pre>Likewise, if f is ⌈ (maximum) then f-reduction of a vector is the largest of
its elements:<pre class=input_T line=664>      ⌈/2 5 12 4 0</pre><pre class=output line=731>12
</pre>The f-reduction of a matrix is a vector with the f-reduction of each row:<pre class=input_T line=664>      3 3⍴1 2 3 4 5 6 7 8 9</pre><pre class=output1 line=732>1 2 3
4 5 6
7 8 9
</pre><pre class=input_ line=665>      +/ (3 3⍴1 2 3 4 5 6 7 8 9)</pre><pre class=output line=731>6 15 24
</pre>f-reduction is one of the functions that support an axis argument.
The axis argument of f-reduction tells along which axis (i.e. rows or columns
in the case of a matrix) the f-reduction shall be performed:<pre class=input_T line=664>      +/[2] (3 3⍴1 2 3 4 5 6 7 8 9)</pre><pre class=output1 line=732>6 15 24
</pre><pre class=input_ line=665>      +/[1] (3 3⍴1 2 3 4 5 6 7 8 9)</pre><pre class=output line=731>12 15 18
</pre>In GNU APL, user defined monadic operators can have an axis argument, which
is, like for their built-in pendants, placed in brackets right of the operator
symbol.<h4><a id=CH_3.3.5></a>3.3.5 Dyadic Operators</h4>A dyadic operator is like a monadic operator but has two function arguments
instead of one.
If <b>OP1</b> is a dyadic operator then <b>(f OP1 g)</b> is its
<b>derived function</b>. Depending on the operator, its derived functions
can be monadic or dyadic. For some dyadic operators their "function
arguments" may or must be APL values and not functions.
The APL symbol for the inner product operator is . (dot). The function arguments
of the inner product are placed immediately left and immediately right of the
dot. If A and B are matrices, then <b>A +.× B</b> is the normal matrix product:<pre class=input_T line=664>      A←3 3⍴1 2 3 4 5 6 7 8 9</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      A</pre><pre class=output1 line=732>1 2 3
4 5 6
7 8 9
</pre><pre class=input_ line=665>      A +.× A</pre><pre class=output line=731> 30  36  42
 66  81  96
102 126 150
</pre>In general, for two matrices A and B and functions f and g, the inner product
f.g is a matrix. The element in row i and column j in that matrix is obtained
by applying function g to row i of A and column j of B and then to perform
f-reduction of the (row i column) vector.
Another way of looking at f.g (or at dyadic operators in general) is to
consider (.g) as a derived monadic operator and f.g as f/(.g).
However, dyadic operators cannot have an axis argument.<h3><a id=CH_3.4></a>3.4 General APL Values</h3>The constants introduced so far were examples of APL values. However, many
APL values cannot be written as constants. In this chapter we will introduce
APL values in a more formal way and we will show how arbitrary APL values
can be constructed.
An APL value is defined by two things: a list of scalars that is called
the <b>ravel</b> of the value, and another list that is called the <b>shape</b>
of the value. The shape determines how the ravel is arranged to
produce an APL value.
For example, the same ravel <b>1 2 3 4 5 6</b> can be arranged (or "shaped")
in 5 different ways:<br><br>1. as a 6-element vector:
<b><pre>      1 2 3 4 5 6
   </pre></b>2. as a 1 by 6 matrix:
<b><pre>      1 2 3 4 5 6
   </pre></b>3. as a 2 by 3 matrix:
<b><pre>      1 2 3
      4 5 6
   </pre></b>4. as a 3 by 2 matrix:
<b><pre>      1 2
      3 4
      5 6
   </pre></b>5. as a 6 by 1 matrix:
<b><pre>      1
      2
      3
      4
      5
      6
   </pre></b><br>In this example, the shape selects between the 5 possible arrangements
of the ravel. The ravel and the shape are not entirely independent.
Instead the following relation is satisfied by every APL value:<br><br><b>The product of all shape elements is equal to the number of ravel elements</b><br><br>The number of shape elements, also called the <b>rank</b> of the value,
determines how many elements the shape has:<br><br><table cellspacing=0 cellpadding=0><tbody><tr><th>Rank<th>Commonly called<tr><td class=tab>0<td class=tabC>Scalar (no shape dimension)<tr><td class=tab>1<td class=tabC>Vector (one shape dimension)<tr><td class=tab>2<td class=tabC>Matrix (two shape dimensions)<tr><td class=tab>3<td class=tabC>Cube (three shape dimensions)<tr><td class=tab>...<td class=tabC>values with higher ranks (more than 3 shape dimensions)</table><br>A value also has a <b>depth</b> which tells the level of nesting. Simple scalars
have a depth if 0. All other values have a depth of
(1 + the maximum depth of all ravel elements). Unlike the shape, which can be
imposed on a value, the depth is a consequence of the rank (scalar or not) and
the ravel of the value.
APL programming is the art of creating new APL values from other APL values.
The starting point is the constants discussed above and the new APL values
are created from existing APL values by calling functions with the existing
APL values as function arguments.
You have probably heard that APL has a large number of built-in functions.
As a consequence, the same new APL value can usually be created in many
different ways. APL programmers tend to prefer the way that contains the
smallest number of function calls, even though that is not always the
"cleanest" way.
It is not always obvious how to create a particular APL value. Therefore we
present a (somewhat awkward) method that always works. This method uses only
a handful of built-in APL functions that - no surprise - belong to the most
frequently used functions in APL programs.<h4><a id=CH_3.4.1></a>3.4.1 Reshape and Shape: ⍴</h4>Reshape is a simple, but powerful, function that creates values of arbitrary
shapes. The function call A ⍴ B returns a new APL value Z with shape A and
a ravel constructed from the ravel of value B as follows.
Let len_B be the number of elements in the ravel of B, and
let len_Z be the number of elements in the ravel of Z.<ul><li>If len_Z = len_B, then the ravel of Z are the ravel of B.<li>If len_Z &lt; len_B, then the ravel of Z are the first len_Z elements
of the ravel of B.<li>If len_Z > len_B, then the ravel of B is appended to itself until one
of the cases above occurs.</ul>Note that the shape of B plays no role in the computation of function reshape.
Most frequently scalars and vectors are being reshaped.
We can now enter the 5 examples above (which are all cases where
len_Z = len_B) in APL:<pre class=input_T line=664>      6 ⍴ 1 2 3 4 5 6</pre><pre class=output1 line=732>1 2 3 4 5 6
</pre><pre class=input_ line=665>      1 6 ⍴ 1 2 3 4 5 6</pre><pre class=output1 line=732>1 2 3 4 5 6
</pre><pre class=input_ line=665>      2 3 ⍴ 1 2 3 4 5 6</pre><pre class=output1 line=732>1 2 3
4 5 6
</pre><pre class=input_ line=665>      3 2 ⍴ 1 2 3 4 5 6</pre><pre class=output1 line=732>1 2
3 4
5 6
</pre><pre class=input_ line=665>      6 1 ⍴ 1 2 3 4 5 6</pre><pre class=output line=731>1
2
3
4
5
6
</pre>An example with len_Z &lt; len_B) is this:<pre class=input_T line=664>      2 2 ⍴ 1 2 3 4 5 6</pre><pre class=output line=731>1 2
3 4
</pre>The most powerful case is len_Z > len_B, in particular when len_B is small:<pre class=input_T line=664>      10 10 ⍴ 1 2</pre><pre class=output line=731>1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
1 2 1 2 1 2 1 2 1 2
</pre>Another illustrative example is the creation of a unity matrix. We will later
repeat the creation of a unity matrix with other functions. Creating a
unity matrix with function reshape is somewhat less "clean" than other
methods, but short and effective (and therefore frequently seen in APL code):<pre class=input_T line=664>      5 5 ⍴ 1 0 0 0 0 0</pre><pre class=output line=731>1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0
0 0 0 0 1
</pre>The monadic variant of ⍴ is called <b>Shape</b> and returns the shape of its
right argument:<pre class=input_T line=664>      ⍴ 1 0 0 0 0 0</pre><pre class=output1 line=732>6
</pre><pre class=input_ line=665>      ⍴ (5 5⍴1 0 0 0 0 0)</pre><pre class=output line=731>5 5
</pre>The parentheses in the last example are not required, but were added for
clarity. Like in other languages, expressions in parentheses are evaluated
first and the result replaces the parentheses and their content.
The shape of a scalar is an empty vector. Empty vectors produce
an empty APL output:<pre class=input_T line=664>      ⍴ 5     ⍝ Shape of a numeric scalar (output is an empty vector)</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      ⍴ ' '   ⍝ Shape of a character scalar (output is an empty vector)</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      ⍴ ''    ⍝ Shape of an empty vector</pre><pre class=output line=731>0
</pre><h4><a id=CH_3.4.2></a>3.4.2 Catenate and Ravel: , and ⍪</h4>The next important function on the way to arbitrary APL values is "catenate",
or dyadic , (comma). The function call A , B appends values A and B. If A
and B are scalars or vectors then the result is somewhat obvious:<pre class=input_T line=664>      1 1 1 , 2 2 2   ⍝ append vector 1 1 1 and vector 2 2 2</pre><pre class=output1 line=732>1 1 1 2 2 2
</pre><pre class=input_ line=665>      1 1 1 , 'bbb'   ⍝ append vector 1 1 1 and vector 'bbb'</pre><pre class=output line=731>1 1 1 bbb
</pre>If A or B is a matrix or a value with even higher rank, then there are
different ways to catenate two values. This is where the optional axis comes
into play. The axis argument determines along which axis
the concatenation shall take place:<pre class=input_T line=664>      2 2⍴'A'</pre><pre class=output1 line=732>AA
AA
</pre><pre class=input_ line=665>      2 2⍴'B'</pre><pre class=output1 line=732>BB
BB
</pre><pre class=input_ line=665>      (2 2⍴'A') ,[1] (2 2⍴'B')</pre><pre class=output1 line=732>AA
AA
BB
BB
</pre><pre class=input_ line=665>      (2 2⍴'A'),[2] (2 2⍴'B')</pre><pre class=output line=731>AABB
AABB
</pre>The axes of a value are the different elements of its shape vector. A scalar
has no axes, a vector has one axis, a matrix has two axes, and so on. When
an APL value is printed then the last axis of the value is printed
horizontally (on the same output line) while the other axes are printed
vertically (on different output lines). The default axis for catenate
(i.e. the axis used when no axis argument is given) is the last axis.
There is a companion function of , (comma) namely ⍪ (comma-bar) that is
identical to comma if an axis is provided, but uses the first axis rather
than the last axis if not. Therefore the last two examples could have
been written without an axis argument like this:<pre class=input_T line=664>      (2 2⍴'A') ⍪ (2 2⍴'B')</pre><pre class=output1 line=732>AA
AA
BB
BB
</pre><pre class=input_ line=665>      (2 2⍴'A') , (2 2⍴'B')</pre><pre class=output line=731>AABB
AABB
</pre><br><br><b>Note:</b> There are some more function pairs that differ only by their default
behavior when no axis argument is given: ⊖ and ⌽, / and ⌿, and \ and ⍀.
The variant with - in the symbol takes the first axis by default while the
other variant takes the last axis.
The monadic variant of , and ⍪ is a monadic function called "ravel" and
returns the ravel of the value. While function reshape can be used,
among other things, to create values of higher or lower ranks than vectors,
function ravel does the opposite: it brings the rank of values with higher
or lower ranks down to rank 1. In other words, function ravel converts a
value with arbitrary shape to a vector. If a value is a vector already then
function ravel returns (a copy of) that vector.<h4><a id=CH_3.4.3></a>3.4.3 Universal Character Set (monadic ⎕UCS)</h4>Function ⎕UCS is monadic and computes a value with the same shape as its
right argument. The right argument must be simple (i.e. not nested) values
whose ravel consists of all integers or all characters. Integers are
converted to characters with the same Unicode, while characters are converted
to an integer with the Unicode of the character.
In most cases the characters that you use in strings will be on your
keyboard, but function ⎕UCS can be used if they are not.
Examples:<pre class=input_T line=664>      ⎕UCS 'APL ⍴⍪ $¥£€⍧ ÄÖÜäöüß'    ⍝ Unicode → integer conversion</pre><pre class=output1 line=732>65 80 76 32 9076 9066 32 36 165 163 8364 9063 32 196 214 220 228 246 252 223
</pre><pre class=input_ line=665>      ⎕UCS 65 80 76 32 9076 9066 32 36 165 163 8364 9063 32 196 214 220 228 246 252 223  ⍝ And back to Unicode</pre><pre class=output line=731>APL ⍴⍪ $¥£€⍧ ÄÖÜäöüß
</pre><h4><a id=CH_3.4.4></a>3.4.4 Construction of arbitrary simple values</h4>The functions reshape, catenate, and occasionally ⎕UCS can be combined
to construct arbitrary simple (i.e. not nested) values. We assume,
of course, that it is known how the value shall look. The algorithm
for constructing the new value is then:<ol><li>construct the shape vector of the new value from smaller items such
as integer scalars or vectors. The integer scalars can be constants or
other integer vectors computed elsewhere. Concatenate (dyadic ,) the
smaller pieces as needed. Put everything in parentheses (in many cases the
parentheses are optional and can be removed, but to be on the safe side we
leave them in).<li>construct the ravel of the new value from smaller items such as
integer scalars, integer vectors, character scalars and character vectors.
Possibly use ⎕UCS to create single charactera or character vectors using
their Unicode. Concatenate (dyadic ,) the smaller pieces as needed.<li>reshape the ravel with the shape vector using dyadic ⍴.</ol>Steps 1 and 2 are independent, so you can do 2 before 1.
As an alert reader you will have noticed that you cannot create new
scalars because a scalar has a shape vector of length 0, and we
have seen earlier that empty integer constants do not exist.
In older APL interpreters this was solved by using an empty character
vector instead of an empty integer vector:<pre class=input_T line=664>      '' ⍴ 1 2 3 4 5 6        ⍝ reshape 1 2 3 4 5 6 to a scalar</pre><pre class=output1 line=732>1
</pre><pre class=input_ line=665>      ⍴ ('' ⍴ 1 2 3 4 5 6)    ⍝ shape of '' ⍴ 1 2 3 4 5 6</pre><pre class=output line=719>
</pre>This worked well and you will find ''⍴ all over the place in older APL programs.
In newer APL interpreters, including GNU APL, a constant ⍬ (zilde) was
introduced. ⍬ is an empty numeric vector. ⍬⍴ is cleaner than ''⍴ because
a shape should always be an integer vector, but the portability of APL programs
using ''⍴ is better than that of ⍬⍴.<br>You may also wonder if vectors can be created with the above algorithm (and
remembering that there are not only no integer vector constants of length 0,
but also no integer vector constants of length 1).
The answer is "yes" because the left argument A of A⍴B can be a vector
or a scalar (the scalar is then treated like a 1-element vector).
Note also, that when creating arbitrary simple vectors, Step 2 alone
suffices in most cases. For simple vectors, steps 1 and 3 are only needed
if the ravel constructed in step 2 has the wrong length.<h4><a id=CH_3.4.5></a>3.4.5 Construction of arbitrary nested values</h4>The <b>depth</b> of a nested value is recursively defined as:<ul><li>0, if the value is a simple scalar<li>1, if the value is a simple vector<li>N+1, if the value is nested and N is the depth of its deepest ravel element</ul>The monadic APL function ≡ (called <b>Depth</b>) returns the depth of an
APL value.<br>In the previous chapter we have seen how arbitrary simple values, i.e.
values of depth 0 or 1 are constructed. We can now create a value of depth
N + 1 recursively:<ul><li>construct the shape vector in the same way as for arbitrary simple values.<li>construct the ravel of the new value from smaller items such as
integer scalars, integer vectors, character scalars and character vectors,
and items with a depth N or less. Enclose non-simple ravel items (i.e. items
with depth > 1) in parentheses.<li>reshape the ravel with the shape vector using dyadic ⍴.</ul>Examples:<pre class=input_T line=664>      1 2 3          ⍝ three element vector</pre><pre class=output1 line=732>1 2 3
</pre><pre class=input_ line=665>      ⍴1 2 3         ⍝ how many elements?</pre><pre class=output1 line=732>3
</pre><pre class=input_ line=665>      ≡1 2 3         ⍝ how deep?</pre><pre class=output1 line=732>1
</pre><pre class=input_ line=665>      1 (2 3)        ⍝ two (!) element vector with nested second element</pre><pre class=output1 line=732> 1  2 3
</pre><pre class=input_ line=665>      ⍴1 (2 3)       ⍝ how many elements?</pre><pre class=output1 line=732>2
</pre><pre class=input_ line=665>      ≡1 (2 3)       ⍝ how deep?</pre><pre class=output1 line=732>2
</pre><pre class=input_ line=665>      1 (2 (3 4))    ⍝ two element vector with nested second element</pre><pre class=output1 line=732> 1   2  3 4
</pre><pre class=input_ line=665>      ⍴1 (2 (3 4))   ⍝ how many elements?</pre><pre class=output1 line=732>2
</pre><pre class=input_ line=665>      ≡1 (2 (3 4))   ⍝ how deep?</pre><pre class=output line=731>3
</pre>When the APL interpreter prints nested values it prints extra spaces
around them. These spaces distinguish nested values from their simple
counterparts with the same ravel elements, but makes it rather difficult
to understand values with deeper nesting.<h4><a id=CH_3.4.6></a>3.4.6 Displaying the structure of values</h4>We have seen in the examples above that that some APL values look the same
(e.g. numeric scalars and numeric vectors) or very similar (nested values
with the same elements in their ravels, like 1 2 3 vs. 1 (2 3) above).
For that reason, APL interpreters that support nested values typically
come with a function called <b>Display</b> that shows the structure of a value
in a clearer way. This function is very useful for analyzing problems that
are caused by different values that look similar:<pre class=input_T line=664>      1 2 3 + 1 2 3      ⍝ add two 3 element vectors</pre><pre class=output1 line=732>2 4 6
</pre><pre class=input_ line=665>      1 2 3 + 1 (2 3)    ⍝ add 3 element vector and 2 element vector</pre><pre class=errput line=742>LENGTH ERROR
      1 2 3+1 (2 3)
      ^    ^
</pre>Since the Display function is of such importance, GNU APL has made it a
built-in function called dyadic ⎕CR. The monadic ⎕CR (character
representation) is a standard function in all APL interpreters that converts
APL values and user defined functions into character strings. The left
argument of dyadic ⎕CR does the same, but its left argument lets you choose
one of several formats. Formats 4 and 8 of ⎕CR select a format that is
very similar to the output of the <b>Display</b> function in other interpreters:<pre class=input_T line=664>      8 ⎕CR 1         ⍝ show structure of scalar 1</pre><pre class=output1 line=732>1
</pre><pre class=input_ line=665>      8 ⎕CR 1 2 3     ⍝ show structure of simple vector 1 2 3</pre><pre class=output1 line=732>┌→────┐
│1 2 3│
└─────┘
</pre><pre class=input_ line=665>      8 ⎕CR 1 (2 3)   ⍝ show structure of nested vector 1 (2 3)</pre><pre class=output1 line=732>┌→──────┐
│1 ┌→──┐│
│  │2 3││
│  └───┘│
└ϵ──────┘
</pre><pre class=input_ line=665>      8 ⎕CR 1 (2 (3 4))   ⍝ show structure of nested vector 1 (2 (3 4))</pre><pre class=output1 line=732>┌→──────────┐
│1 ┌→──────┐│
│  │2 ┌→──┐││
│  │  │3 4│││
│  │  └───┘││
│  └ϵ──────┘│
└ϵϵ─────────┘
</pre><pre class=input_ line=665>      8 ⎕CR (2 2⍴ 1 2 3 4)    ⍝ show structure of simple matrix 2 2 ⍴ 1 2 3 4</pre><pre class=output1 line=732>┌→──┐
↓1 2│
│3 4│
└───┘
</pre><pre class=input_ line=665>      8 ⎕CR (2 2⍴ 1 2 3 (2 2⍴4))    ⍝ a nested matrix</pre><pre class=output line=731>┌→──────┐
↓1     2│
│       │
│3 ┌→──┐│
│  ↓4 4││
│  │4 4││
│  └───┘│
└ϵ──────┘
</pre>8 ⎕CR is a character matrix constructed according to the following rules:<ul><li>the matrix consists of a <b>frame</b> (solid line) that surrounds
its <b>content</b>.<li>The content is created from the ravel elements of the value that are
arranged according to the shape of the value. If a ravel element is a
nested value then that value is displayed with its own frame (and these rules
apply recursively.<li>The frame can contain additional indicators. If the rank of the value
is ≥ 1 then the horizontal top line of the frame contains information
pertaining to the last dimension of the value. If the rank of the value
is ≥ 2 then the vertical left line of the frame contains information
pertaining to the other dimensions of the value. The horizontal bottom line
of the frame is related to the depth of the ravel.<li>An arrow (→ on the top line or ↓ on the left line) indicates that the
corresponding dimension(s) are present and non-empty.<li>An ⊖ on the top line or ⌽ on the left line) indicates that the
corresponding dimension(s) are present but empty. In this case the ravel
has length 0 and instead of the empty ravel the <b>prototype</b> of the value
(a concept explained later on) is shown.<li>An ∊ on the bottom line indicates that the ravel contains nested elements;
multiple ∊ indicate deeper nesting.</ul><h4><a id=CH_3.4.7></a>3.4.7 Vector Notation versus Catenation</h4>For beginners the difference between vector notation (a sequence of items
separated by spaces) and catenation (a sequence of items separated by commas)
can be confusing because often, in particular for simple scalars and vectors,
both of them produce the same result:<pre class=input_T line=664>      1 2 3</pre><pre class=output1 line=732>1 2 3
</pre><pre class=input_ line=665>      1,2,3</pre><pre class=output line=731>1 2 3
</pre>In the example above, vector notation executes faster because no function
needs to be computed. Sometimes, however, vector notation may produce a
result other than expected:<pre class=input_T line=664>      1 2 3 (4 5)</pre><pre class=output1 line=732> 1 2 3  4 5
</pre><pre class=input_ line=665>      8 ⎕CR 1 2 3 (4 5)</pre><pre class=output1 line=732>┌→──────────┐
│1 2 3 ┌→──┐│
│      │4 5││
│      └───┘│
└ϵ──────────┘
</pre><pre class=input_ line=665>      1 2 3,(4 5)</pre><pre class=output1 line=732>1 2 3 4 5
</pre><pre class=input_ line=665>      8 ⎕CR 1 2 3,(4 5)</pre><pre class=output line=731>┌→────────┐
│1 2 3 4 5│
└─────────┘
</pre>Vector notation starts with the leftmost item and adds one item for every
space (or group of spaces). If an item added is not a scalar (like (4 5) in
the example above) then the item is automatically converted to a nested
value.
Catenation works differently; in the above example the two vectors 1 2 3 and
(4 5) are simply concatenated to form a vector of length 5.
The parentheses in (4 5) in in the catenation example were redundant, while
the parentheses in the vector notation were not. Once again 8 ⎕CR helped to
clarify the matter.<h4><a id=CH_3.4.8></a>3.4.8 Scalar Extension</h4>Before continuing we need to introduce a fundamental APL mechanism called
<b>scalar extension</b>. This mechanism is applied in many places.<br>Almost all built-in APL functions are partial, which means that there are
arguments for which the function returns an error instead of a result. Some
of the very few total (i.e. non-partial) functions are monadic ⍴
and monadic ≡. Typically dyadic functions put more requirements on their
arguments than monadic functions. The reason is that not only must the
individual left and right arguments satisfy some conditions, but the left
and right arguments must also fit each other. For example:<pre class=input_T line=664>      1 2 3 + 1 2 3   ⍝ 1 2 3 is a valid arguments for +</pre><pre class=output1 line=732>2 4 6
</pre><pre class=input_ line=665>      1 2 + 1 2       ⍝ 1 2 is also a valid arguments for +</pre><pre class=output1 line=732>2 4
</pre><pre class=input_ line=665>      1 2 + 1 2 3     ⍝ they cannot be mixed, though</pre><pre class=errput line=742>LENGTH ERROR
      1 2+1 2 3
      ^  ^
</pre>The most common requirement of dyadic functions is that the left
and right argument have the same shape. The sum of two 3 element vectors
makes sense, while the sum of a 2 element vector and a 3 element vector
does not:<pre class=input_T line=664>      1 2 3 + 4 5 6    ⍝ OK to add two 3 element vectors</pre><pre class=output1 line=732>5 7 9
</pre><pre class=input_ line=665>      1 2 3 + 4 5      ⍝ not OK to add 2 element vector to 3 element vector</pre><pre class=errput line=742>LENGTH ERROR
      1 2 3+4 5
      ^    ^
</pre>Now scalar extension is an exception to most matching shape requirements.
If one of the arguments of a dyadic function is a scalar, and if the function
supports scalar extension, then the scalar argument is automatically reshaped
to the shape of the other argument. (If both arguments were scalar, then they
have the same shape already and scalar extension would have no noticeable
effect).<pre class=input_T line=664>      1 2 3 + 4      ⍝ OK by virtue of scalar extension of right argument</pre><pre class=output1 line=732>5 6 7
</pre><pre class=input_ line=665>      1 + 4 5 6      ⍝ OK by virtue of scalar extension of left argument</pre><pre class=output line=731>5 6 7
</pre>Scalar extension is applied recursively. If some ravel element of a
value A is nested and the corresponding ravel of B is not (or vice
versa) then the non-nested element is scalar extended to the other:<pre class=input_T line=664>      1 2 3 4 + 1 2 3      ⍝ expect length error</pre><pre class=errput1 line=743>LENGTH ERROR
      1 2 3 4+1 2 3
      ^      ^
</pre><pre class=input_ line=665>      1 2 (3 4) + 1 2 3    ⍝ 3 is scalar extended to match (3 4)</pre><pre class=output line=731> 2 4  6 7
</pre><h4><a id=CH_3.4.9></a>3.4.9 List of Built-in Scalar Functions</h4>The power of APL comes from the large number of built-in functions.
Most of them belong to a category called scalar functions and below is
a list of them. Normally the monadic and the dyadic variants are closely
related and are both scalar functions. An exception is ∼ where the monadic
form is a scalar function while the dyadic form is not.<br><br><table class=table1 cellspacing=0 cellpadding=0><tbody><tr><th class=tab12 colspan=2>Dyadic: Z←A FUN B<th class=tab3>FUN<th class=tab45 colspan=2>Monadic: Z←FUN B<tr><th class=tab1>Name/Description<th class=tab2>Example(s)<th class=tab3>&nbsp;<th class=tab4>Name/Description<th class=tab5 colspan=5>Example(s)<tr><td class=tab1><b>Plus</b><br>Z is A plus B<td class=tab12><pre class=input4 line=658>      2 + 3</pre><pre class=output4 line=730>5
</pre><td class=tab3>+<td class=tab4><b>Conjugate</b><br>Z is the complex<br>conjugate of B<td class=tab5><pre class=input4 line=658>      + 1J42</pre><pre class=output4 line=730>1J¯42
</pre><tr><td class=tab1><b>Minus</b><br>Z is A minus B<td class=tab12><pre class=input4 line=658>      2 - 3</pre><pre class=output4 line=730>¯1
</pre><td class=tab3>-<td class=tab4><b>Negative</b><br>Z is the negative of B<td class=tab5><pre class=input4 line=658>      - ¯2</pre><pre class=output4 line=730>2
</pre><tr><td class=tab1><b>Times</b><br>Z is A times B<td class=tab12><pre class=input4 line=658>      2 × 3</pre><pre class=output4 line=730>6
</pre><td class=tab3>×<td class=tab4><b>Direction</b><br>Z is 1, 0, or ¯1
if B > 0, B = 0, or B &lt; 0 resp.<td class=tab5><pre class=input4 line=658>      × ¯5</pre><pre class=output4 line=730>¯1
</pre><tr><td class=tab1><b>Divide</b><br>Z is A divided by B<td class=tab12><pre class=input4 line=658>      3÷2</pre><pre class=output4 line=730>1.5
</pre><td class=tab3>÷<td class=tab4><b>Reciprocal</b><br>Z is 1 ÷ B<td class=tab5><pre class=input4 line=658>      ÷4</pre><pre class=output4 line=730>0.25
</pre><tr><td class=tab1><b>Minimum</b><br>Z is the smaller of A and B<td class=tab12><pre class=input4 line=658>      2 ⌊ 3</pre><pre class=output4 line=730>2
</pre><td class=tab3>⌊<td class=tab4><b>Floor</b><br>Z is B rounded down<td class=tab5><pre class=input4 line=658>      ⌊ 4.7</pre><pre class=output4 line=730>4
</pre><tr><td class=tab1><b>Maximum</b><br>Z is the larger of A and B<td class=tab12><pre class=input4 line=658>      2 ⌈ 3</pre><pre class=output4 line=730>3
</pre><td class=tab3>⌈<td class=tab4><b>Ceiling</b><br>Z is B rounded up<td class=tab5><pre class=input4 line=658>      ⌈ 4.7</pre><pre class=output4 line=730>5
</pre><tr><td class=tab1><b>Power</b><br>Z is A raised to<br>the B<sup>th</sup> power<td class=tab12><pre class=input4 line=658>      2⋆3</pre><pre class=output4 line=730>8
</pre><td class=tab3>⋆<td class=tab4><b>Exponential</b><br>Z is <b>e</b> to<br>the B<sup>th</sup> power<td class=tab5><pre class=input4 line=658>      ⋆1</pre><pre class=output4 line=730>2.718281828
</pre><tr><td class=tab1><b>Logarithm</b><br>Z is the logarithm<br>of B to base A<td class=tab12><pre class=input4 line=658>      2⍟8</pre><pre class=output4 line=730>3
</pre><td class=tab3>⍟<td class=tab4><b>Natural Logarithm</b><br>Z is the natural<br>logarithm of B<td class=tab5><pre class=input4 line=658>      ⍟8</pre><pre class=output4 line=730>2.079441542
</pre><tr><td class=tab1><b>Residue</b><br>Z is B modulo A<td class=tab12><pre class=input4 line=658>      10∣13</pre><pre class=output4 line=730>3
</pre><td class=tab3>∣<td class=tab4><b>Magnitude</b><br>Z is the magnitude of B<td class=tab5><pre class=input4 line=658>      ∣3J4</pre><pre class=output4 line=730>5
</pre><tr><td class=tab1><b>Binomial</b><br>Z is Γ(1+B) ÷ (Γ(1+A) × Γ(1+B-A))<br><br>For integers A≥0 and B≥0:<br>Z is (B!) ÷ ((A!) × (B-A)!)<td class=tab12><pre class=input4 line=658>      3!5   ⍝ aka. 5 over 3</pre><pre class=output4 line=730>10
</pre><td class=tab3>!<td class=tab4><b>Factorial</b><br>Z is Γ(1+B), aka.<br>B! for integers B≥0<td class=tab5><pre class=input4 line=658>      !4   ⍝ factorial of B</pre><pre class=output4 line=730>24
</pre><tr><td class=tab1><b>Circular Functions</b><br>Z is a function, selected<br>by integer A, and called<br>with argument B:<br><br><b>A=¯12</b>: exp(iB)<br><b>A=¯11</b>: iB<br><b>A=¯10</b>: +B<br><b>A=¯9</b>: B<br><b>A=¯8</b>: sqrt(B<sup>2</sup> - 1)<br><b>A=¯7</b>: atanh(B)<br><b>A=¯6</b>: acosh(B)<br><b>A=¯5</b>: asinh(B)<br><b>A=¯4</b>: (B+1) × sqrt((B-1)÷(B+1)))<br><b>A=¯3</b>: atan(B)<br><b>A=¯2</b>: acos(B)<br><b>A=¯1</b>: asin(B)<br><b>A=0</b>: sqrt(1 - B<sup>2</sup>)<br><b>A=1</b>: sin(B)<br><b>A=2</b>: cos(B)<br><b>A=3</b>: tan(B)<br><b>A=4</b>: sqrt(1 + B<sup>2</sup>)<br><b>A=5</b>: sinh(B)<br><b>A=6</b>: cosh(B)<br><b>A=7</b>: tanh(B)<br><b>A=8</b>: sqrt(¯1 - B<sup>2</sup>)<br><b>A=9</b>: real(B)<br><b>A=10</b>: ∣ B<br><b>A=11</b>: imag(B)<br><b>A=12</b>: arc(B)<td class=tab12><pre class=input4 line=658>      A,⍪(A←¯13+⍳25) ○ 1.1</pre><pre class=output4 line=730>¯12 0.4535961214J0.8912073601
¯11            0J1.1
¯10          1.1
 ¯9          1.1
 ¯8            0J1.486606875
 ¯7  1.522261219J¯1.570796327
 ¯6 0.4435682544
 ¯5 0.9503469298
 ¯4 0.4582575695
 ¯3 0.8329812667
 ¯2            0J¯0.4435682544
 ¯1  1.570796327J¯0.4435682544
  0            0J0.4582575695
  1 0.8912073601
  2 0.4535961214
  3  1.964759657
  4  1.486606875
  5   1.33564747
  6  1.668518554
  7 0.8004990218
  8            0J¯1.486606875
  9          1.1
 10          1.1
 11            0
 12            0
</pre><td class=tab3>○<td class=tab4><b>Pi Times</b><br>Z is Pi times B<td class=tab5><pre class=input4 line=658>      ○1</pre><pre class=output4 line=730>3.141592654
</pre><pre class=input4 line=658>      ○2</pre><pre class=output4 line=730>6.283185307
</pre><tr><td class=tab1><b>Without</b><br>Z is the elements of A<br>that are not in B<td class=tab12><pre class=input4 line=658>      1 2 3 4 5 6 ∼ 3 4</pre><pre class=output4 line=730>1 2 5 6
</pre><td class=tab3>∼<td class=tab4><b>Not</b><br>Z is the boolean<br>complement of B<td class=tab5><pre class=input4 line=658>      ∼ 1 0 1 1 0 0</pre><pre class=output4 line=730>0 1 0 0 1 1
</pre><tr><td class=tab1><b>And/LCM</b><br>For boolean A and B is Z the<br>logical AND of A and B.<br><br>For integer A or B is Z the<br>least common multiple of A and B<td class=tab12><pre class=input4 line=658>      0 0 1 1 ∧ 0 1 0 1</pre><pre class=output4 line=730>0 0 0 1
</pre><td class=tab3>∧<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      ∧ 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      ∧0 1 0 1
      ^
</pre><tr><td class=tab1><b>Or/GCD</b><br>For boolean A and B is Z the<br>logical OR of A and B<br><br>For integer A and B is Z the<br>gratest common divisor of A and B<td class=tab12><pre class=input4 line=658>      0 0 1 1 ∨ 0 1 0 1</pre><pre class=output4 line=730>0 1 1 1
</pre><td class=tab3>∨<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      ∨ 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      ∨0 1 0 1
      ^
</pre><tr><td class=tab1><b>Nand</b><br>Z is ∼ (A ∧ B)<td class=tab12><pre class=input4 line=658>      0 0 1 1 ⍲ 0 1 0 1</pre><pre class=output4 line=730>1 1 1 0
</pre><td class=tab3>⍲<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      ⍲ 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      ⍲0 1 0 1
      ^
</pre><tr><td class=tab1><b>Nor</b><br>Z is ∼ (A ∨ B)<td class=tab12><pre class=input4 line=658>      0 0 1 1 ⍱ 0 1 0 1</pre><pre class=output4 line=730>1 0 0 0
</pre><td class=tab3>⍱<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      ⍱ 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      ⍱0 1 0 1
      ^
</pre><tr><td class=tab1><b>Equal</b><br>Z is 1 for equal A and B,<br>and 0 otherwise.<td class=tab12><pre class=input4 line=658>      1 2 3 = 2</pre><pre class=output4 line=730>0 1 0
</pre><td class=tab3>=<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      = 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      =0 1 0 1
      ^
</pre><tr><td class=tab1><b>Less Than</b><br>Z is 1 if A is less than B,<br>and 0 otherwise.<td class=tab12><pre class=input4 line=658>      1 2 3 &lt; 2</pre><pre class=output4 line=730>1 0 0
</pre><td class=tab3>&lt;<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      &lt; 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      &lt;0 1 0 1
      ^
</pre><tr><td class=tab1><b>Less or Equal</b><br>Z is 1 if A s less than or<br>equal to B, and 0 otherwise<td class=tab12><pre class=input4 line=658>      1 2 3 ≤ 2</pre><pre class=output4 line=730>1 1 0
</pre><td class=tab3>≤<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      ≤ 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      ≤0 1 0 1
      ^
</pre><tr><td class=tab1><b>Not Equal</b><br>Z is 1 if A differs from B,<br>and 0 otherwise<td class=tab12><pre class=input4 line=658>      1 2 3 ≠ 2</pre><pre class=output4 line=730>1 0 1
</pre><td class=tab3>≠<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      ≠ 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      ≠0 1 0 1
      ^
</pre><tr><td class=tab1><b>Greater or Equal</b><br>Z is 1 if A s greater than or<br>equal to B, and 0 otherwise<td class=tab12><pre class=input4 line=658>      1 2 3 ≥ 2</pre><pre class=output4 line=730>0 1 1
</pre><td class=tab3>≥<td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      ≥ 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      ≥0 1 0 1
      ^
</pre><tr><td class=tab1><b>Greater Than</b><br>Z is 1 if A is greater than B,<br>and 0 otherwise<td class=tab12><pre class=input4 line=658>      1 2 3 &gt; 2</pre><pre class=output4 line=730>0 0 1
</pre><td class=tab3>><td class=tab4><b>N/A</b><td class=tab5><pre class=input4 line=658>      &gt; 0 1 0 1</pre><pre class=errput4 line=741>VALENCE ERROR
      &gt;0 1 0 1
      ^
</pre></table><h4><a id=CH_3.4.10></a>3.4.10 List of Other Built-in Functions</h4>To have all functions listed in one place, we also provide the
remaining build-in APL functions here. These functions are either
represented by a single APL character, or by a name that starts with ⎕,
followed by one or more letters from A-Z ("quad functions"). There is no
big difference between quad functions and other built-in functions, except
for the name. Often quad functions are used for services of the
underlying operating system, such as time information, user accounting, etc.
Note that the non-quad functions are all defined by the ISO APL standard
(and identical on all APL interpreters), while very few quad-functions
are defined by the standard and the other ones differ considerably between
different APL interpreters.<br><br><b>Note:</b> The table below uses the concept of APL variables which have not
been introduced yet (but will be soon). If you are an APL novice then please
ignore the table for the moment and return to it after variables have been
introduced.<br><br><table class=table1 cellspacing=0 cellpadding=0><tbody><tr><th class=tab12 colspan=2>Dyadic: Z←A FUN B<th class=tab3>FUN<th class=tab45 colspan=2>Monadic: Z←FUN B<tr><th class=tab1>Name/Description<th class=tab2>Example(s)<th class=tab3>&nbsp;<th class=tab4>Name/Description<th class=tab5 colspan=5>Example(s)<tr><td class=tab1><b>Reshape</b><br>Z is the ravel of B (possibly shortened or replicated
as needed) with shape A<td class=tab12><pre class=input4 line=658>      2 3⍴1 2 3 4 5 6</pre><pre class=output4 line=730>1 2 3
4 5 6
</pre><td class=tab3>⍴<td class=tab4><b>Shape</b><br>Z is the shape of B<td class=tab5><pre class=input4 line=658>      ⍴ (2 3 ⍴ 1 2 3 4 5 6)</pre><pre class=output4 line=730>2 3
</pre><tr><td class=tab1><b>Join</b><br>Z is the concatenation of A and B<td class=tab12><pre class=input4 line=658>      A ← 2 3⍴'abcdef' ◊ B ← 2 3⍴1 2 3 4 5 6<pre class=output4 line=718>
</pre>A<pre class=output4 line=730>abc
def
</pre>B<pre class=output4 line=730>1 2 3
4 5 6
</pre>A,B</pre><pre class=output4 line=730>abc 1 2 3
def 4 5 6
</pre><td class=tab3>,<br>⍪<td class=tab4><b>Ravel</b><br>,B is the ravel of B (a vector with the same elements as B.<br><br><b>Table</b><br>⍪B is a 2-dimensional matrix with the elements of B.)<td class=tab5><pre class=input4 line=658>      ⎕ ← B ← 2 3 ⍴ 1 2 3 4 5 6</pre><pre class=output4 line=730>1 2 3
4 5 6
</pre><pre class=input4 line=658>      ,B</pre><pre class=output4 line=730>1 2 3 4 5 6
</pre><pre class=input4 line=658>      ⎕ ← B ← 1 2 3 4 5</pre><pre class=output4 line=730>1 2 3 4 5
</pre><pre class=input4 line=658>      ⍪B</pre><pre class=output4 line=730>1
2
3
4
5
</pre><tr><td class=tab1><b>Index of</b><br>Z is the positions of B's elements in A<td class=tab12><pre class=input4 line=658>      'abcdefgh' ⍳ 'hello'</pre><pre class=output4 line=730>8 5 9 9 9
</pre><td class=tab3>⍳<td class=tab4><b>Index Generator</b><br>Z is 1 2 ... B<td class=tab5><pre class=input4 line=658>      ⍳6</pre><pre class=output4 line=730>1 2 3 4 5 6
</pre><tr><td class=tab1><b>Identical</b><br>Z is 1 if A and B have the same shape and the same
ravel elements (including identical nested ravel elements), and 0
otherwise.<td class=tab12><pre class=input4 line=658>      1 2 3 ≡ 1 2 3   ⍝ same shapes and ravels</pre><pre class=output4 line=730>1
</pre><pre class=input4 line=658>      1 2 3 = 1 2 5   ⍝ for comparison: equal</pre><pre class=output4 line=730>1 1 0
</pre><pre class=input4 line=658>      1 2 3 ≡ 1 2 5   ⍝ same shapes, different ravels</pre><pre class=output4 line=730>0
</pre><pre class=input4 line=658>      1  ≡ ,1   ⍝ same ravel, different shapes</pre><pre class=output4 line=730>0
</pre><td class=tab3>≡<td class=tab4><b>Depth</b><br>Z is the depth (the level of nesting) of B<td class=tab5><pre class=input4 line=658>      ≡ 1</pre><pre class=output4 line=730>0
</pre><pre class=input4 line=658>      ≡ 1 2 3</pre><pre class=output4 line=730>1
</pre><pre class=input4 line=658>      ≡ 1 (2 3) 4</pre><pre class=output4 line=730>2
</pre><tr><td class=tab1><b>Not Identical</b><br>Z is 0 if A and B have the same shape and the same
ravel elements (including identical nested ravel elements), and 1
otherwise.<td class=tab12><pre class=input4 line=658>      1 2 3 ≢ 1 2 3   ⍝ same shapes and ravels</pre><pre class=output4 line=730>0
</pre><pre class=input4 line=658>      1 2 3 ≠ 1 2 5   ⍝ for comparison: not equal</pre><pre class=output4 line=730>0 0 1
</pre><pre class=input4 line=658>      1 2 3 ≢ 1 2 5   ⍝ same shapes, different ravels</pre><pre class=output4 line=730>1
</pre><pre class=input4 line=658>      1  ≢ ,1   ⍝ same ravel, different shapes</pre><pre class=output4 line=730>1
</pre><td class=tab3>≢<td class=tab4><b>Tally</b><br>Z is the length of the first axis of B<td class=tab5><pre class=input4 line=658>      ≢ 1</pre><pre class=output4 line=730>1
</pre><pre class=input4 line=658>      ≢ 2 3⍴1 2 3</pre><pre class=output4 line=730>2
</pre><pre class=input4 line=658>      ≢ 4 3⍴1 2 3</pre><pre class=output4 line=730>4
</pre><pre class=input4 line=658>      ≢ 1 (2 3) 4</pre><pre class=output4 line=730>3
</pre><tr><td class=tab1><b>Member of</b><br>Z is a Boolean value with the same shape as A.
The elements of Z indicate if the corresponding element in A is
equal to some element in B.<td class=tab12><pre class=input4 line=658>      (2 3⍴1 2 3 4 5 6) ϵ 4 5 6 7 8</pre><pre class=output4 line=730>0 0 0
1 1 1
</pre><td class=tab3>∈<td class=tab4><b>Enlist</b><br>Z is the elements of B listed in depth-first order (all
nested sub-values of a ravel element come before the
next ravel element at the same level).<td class=tab5><pre class=input4 line=658>      ∈ (1 2 3) (4 5) 6</pre><pre class=output4 line=730>1 2 3 4 5 6
</pre><tr><td class=tab1><b>Deal</b><br>Z is a subset of ⎕IO ... ⎕IO+B containing A elements
chosen at random<td class=tab12><pre class=input4 line=658>      3 ? 10</pre><pre class=output4 line=730>7 9 4
</pre><pre class=input4 line=658>      3 ? 10</pre><pre class=output4 line=730>4 2 10
</pre><td class=tab3>?<td class=tab4><b>Roll</b><br>Z has the same shape as B. The elements of Z are random
numbers between ⎕IO and ⎕IO+b where b is the corresponding
element in B.<td class=tab5><pre class=input4 line=658>      ? 10 100 1000</pre><pre class=output4 line=730>5 95 697
</pre><tr><td class=tab1><b>Grade Up/Down with collating sequence</b><br>A is a character array which defines a sorting order for
characters. B is a character vector (string) to be sorted.
Z is an integer vector such that B[Z] is sorted according to the
sorting order defined by A.<td class=tab12><pre class=input4 line=658>      ⎕IO←1                         ⍝ ⍋ and ⍒ depend on ⎕IO</pre><pre class=output4 line=718>
</pre><pre class=input4 line=658>      ⊢B←5 4⍴'DEADBADECEDEBEADDEE'  ⍝ B: the items to be sorted</pre><pre class=output4 line=730>DEAD
BADE
CEDE
BEAD
DEED
</pre><pre class=input4 line=658>      'ABCDE' ⍋ B                   ⍝ sort B with A &lt; B &lt; C &lt; D &lt; E</pre><pre class=output4 line=730>2 4 3 1 5
</pre><pre class=input4 line=658>      B['ABCDE' ⍋ B;]               ⍝ the sorted items</pre><pre class=output4 line=730>BADE
BEAD
CEDE
DEAD
DEED
</pre><pre class=input4 line=658>      B['CBADE' ⍋ B;]               ⍝ same with C &lt; B &lt; A &lt; D &lt; E</pre><pre class=output4 line=730>CEDE
BADE
BEAD
DEAD
DEED
</pre><td class=tab3>⍋<br>⍒<td class=tab4><b>Grade Up/Down</b><br>Z is a vector of indices such that B[Z] is ordered
ascendingly (⍋) or descendingly (⍒). In other words, B[⍋B] is B
sorted in ascending order and B[⍒B] is B sorted in descending order.<td class=tab5><pre class=input4 line=658>      ⍋ B←1 7 4 2 6</pre><pre class=output4 line=730>1 4 3 5 2
</pre><pre class=input4 line=658>      B[⍋B]</pre><pre class=output4 line=730>1 2 4 6 7
</pre><pre class=input4 line=658>      B[⍒B]</pre><pre class=output4 line=730>7 6 4 2 1
</pre><tr><td class=tab1><b>Representation aka. Encode</b><br>Z is numbers in B represented in the number system with radices A.
⍴A determines the number of digits in that representation.<td class=tab12><pre class=input4 line=658>      2 2 2 2 2 2 ⊤ 42   ⍝ 42 in base 2 (aka. binary) with 6 digits</pre><pre class=output4 line=730>1 0 1 0 1 0
</pre><td class=tab3>⊤<td class=tab4>N/A<td class=tab5><pre class=input4 line=658>      ⊤ 42</pre><pre class=errput4 line=741>VALENCE ERROR
      ⊤42
      ^
</pre><tr><td class=tab1><b>Base Value aka. Decode</b><br>Z is the number corresponding to the digits B in the number system
with radices A.<td class=tab12><pre class=input4 line=658>      2 ⊥ 1 0 1 0 1 0   ⍝ binary 1 0 1 0 1 0 in decimal</pre><pre class=output4 line=730>42
</pre><td class=tab3>⊥<td class=tab4>N/A<td class=tab5><pre class=input4 line=658>      ⊥ 42</pre><pre class=errput4 line=741>VALENCE ERROR
      ⊥42
      ^
</pre><tr><td class=tab1><b>Union</b><br>Z is A , B (with duplicates of A in B removed)<td class=tab12><pre class=input4 line=658>      1 2 2 3 'A' ∪ 3 'B' 'C' 'A'</pre><pre class=output4 line=730>1 2 2 3 ABC
</pre><td class=tab3>∪<td class=tab4><b>Unique</b><br>Z is B with duplicate elements removed<td class=tab5><pre class=input4 line=658>      ∪ 1 2 3 4 3 5</pre><pre class=output4 line=730>1 2 3 4 5
</pre><tr><td class=tab1><b>Format</b><br>Z is B formatted according to A<td class=tab12><pre class=input4 line=658>      ⊢B←3 2ρ1 .468987 2 57.276 3 27963</pre><pre class=output4 line=730>1     0.468987
2    57.276
3 27963
</pre><pre class=input4 line=658>      ⍝ format by specification: (field size + precision)</pre><pre class=input4 line=658>      ⍝ precisions &lt; 0 imply exponential format</pre><pre class=input4 line=658>      4 2 12 ¯5 ⍕ B   ⍝ field sizes 4 and 12, precisions 2 and ¯5</pre><pre class=output4 line=730>1.00   4.6899E¯1
2.00   5.7276E1
3.00   2.7963E4
</pre><pre class=input4 line=658>      ⍝ format by example: (example string A)</pre><pre class=input4 line=658>      ⊢B←234.67 456.23 987.65 34.23</pre><pre class=output4 line=730>234.67 456.23 987.65 34.23
</pre><pre class=input4 line=658>      "SUM: $5,555.50" ⍕ +/ B</pre><pre class=output4 line=730>SUM: $1,712.78
</pre><td class=tab3>⍕<td class=tab4><b>Format</b><br>Z is B for strings; otherwise B converted to a character vector or matrix<td class=tab5><tr><td class=tab1>N/A<td class=tab12><pre class=input4 line=658>      2 ⍎ 42</pre><pre class=errput4 line=741>VALENCE ERROR
      2⍎42
      ^^
</pre><td class=tab3>⍎<td class=tab4><b>Execute</b><br>Z is the result of executing string B as APL expression<td class=tab5><tr><td class=tab1><b>Take</b><br>Z is a rectangular sub-area of B according to A<td class=tab12><pre class=input4 line=658>      ⊢V←⍳7</pre><pre class=output4 line=730>1 2 3 4 5 6 7
</pre><pre class=input4 line=658>      3↑V</pre><pre class=output4 line=730>1 2 3
</pre><pre class=input4 line=658>      ¯3↑V</pre><pre class=output4 line=730>5 6 7
</pre><pre class=input4 line=658>      ⊢B←7 7⍴⍳49</pre><pre class=output4 line=730> 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31 32 33 34 35
36 37 38 39 40 41 42
43 44 45 46 47 48 49
</pre><pre class=input4 line=658>      3 3↑B</pre><pre class=output4 line=730> 1  2  3
 8  9 10
15 16 17
</pre><pre class=input4 line=658>      ¯3 ¯3↑B</pre><pre class=output4 line=730>33 34 35
40 41 42
47 48 49
</pre><td class=tab3>↑<td class=tab4><b>First</b><br>Z is a Scalar containing first element of B (or the prototype of B if B is empty)<td class=tab5><tr><td class=tab1><b>Drop</b><br>Z is B rectangular sub-area of B according to A<td class=tab12><pre class=input4 line=658>      ⊢V←⍳7</pre><pre class=output4 line=730>1 2 3 4 5 6 7
</pre><pre class=input4 line=658>      3↓V</pre><pre class=output4 line=730>4 5 6 7
</pre><pre class=input4 line=658>      ¯3↓V</pre><pre class=output4 line=730>1 2 3 4
</pre><pre class=input4 line=658>      ⊢B←7 7⍴⍳49</pre><pre class=output4 line=730> 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31 32 33 34 35
36 37 38 39 40 41 42
43 44 45 46 47 48 49
</pre><pre class=input4 line=658>      3 3↓B</pre><pre class=output4 line=730>25 26 27 28
32 33 34 35
39 40 41 42
46 47 48 49
</pre><pre class=input4 line=658>      ¯3 ¯3↓B</pre><pre class=output4 line=730> 1  2  3  4
 8  9 10 11
15 16 17 18
22 23 24 25
</pre><td class=tab3>↓<td class=tab4>N/A<td class=tab5><pre class=input4 line=658>      ↓ 1 2 3</pre><pre class=errput4 line=741>VALENCE ERROR
      ↓1 2 3
      ^
</pre><tr><td class=tab1><b>Find</b><br>Z[i] is 1 if A starts at B[i] in B and 0 if not.<td class=tab12><pre class=input4 line=658>      3 4 ⍷ 1 2 3 4 5</pre><pre class=output4 line=730>0 0 1 0 0
</pre><td class=tab3>⋸<td class=tab4>N/A<td class=tab5><pre class=input4 line=658>      ⋸ 'abc'</pre><pre class=errput4 line=741>VALENCE ERROR
      ⍷'abc'
      ^
</pre><tr><td class=tab1><b>Index</b><br>Z is B[A]<td class=tab12><pre class=input4 line=658>      2 ⌷ 'Hello'</pre><pre class=output4 line=730>e
</pre>⍝ second character<td class=tab3>⌷<td class=tab4>N/A<td class=tab5><pre class=input4 line=658>      ⌷ 1 2 3</pre><pre class=errput4 line=741>VALENCE ERROR
      ⌷1 2 3
      ^
</pre><tr><td class=tab1><b>Right</b><br>Z is B.<td class=tab12><pre class=input4 line=658>      'Left' ⊢  'Right'</pre><pre class=output4 line=730>Right
</pre><td class=tab3>⊢<td class=tab4><b>Identity</b><br>Z is B. ⊢B is a shortcut for ⎕←B<td class=tab5><tr><td class=tab1><b>Left</b><br>Z is A<td class=tab12><pre class=input4 line=658>      'Left' ⊣  'Right'</pre><pre class=output4 line=730>Left
</pre><td class=tab3>⊣<td class=tab4><b>Hide</b><br>Z is B as a committed APL value (and is therefore not
automatically displayed). ⊣B is a shortcut for (⍳0)⍴B.<td class=tab5><pre class=input4 line=658>      1 + 3</pre><pre class=output4 line=730>4
</pre><pre class=input4 line=658>      ⊣ 1 + 3</pre><pre class=output4 line=718>
</pre><tr><td class=tab1><b>Partition</b><br>Z is B, divided into partitions according to A. Two elements B[b]
and B[b+1] of B belong to the same partition if A[b] ≥ A[b+1] > 0.
Each partition becomes a nested item of Z where B[b] with A[b] = 0
are removed.<td class=tab12><pre class=input4 line=658>      1 1  2 2  3 3 3 3 ⊂ 'ABCDEFGH'   ⍝ 3 partitions</pre><pre class=output4 line=730> AB CD EFGH
</pre><pre class=input4 line=658>      1 1  0 0  3 3 3 3 ⊂ 'ABCDEFGH'   ⍝ 2 partitions</pre><pre class=output4 line=730> AB EFGH
</pre><td class=tab3>⊂<td class=tab4><b>Enclose</b><br>Z is B for simple scalars, otherwise a scalar
that contains B as a nested value<td class=tab5><pre class=input4 line=658>      B←3 4 ⍴5</pre><pre class=output4 line=718>
</pre><pre class=input4 line=658>      8 ⎕CR B</pre><pre class=output4 line=730>┌→──────┐
↓5 5 5 5│
│5 5 5 5│
│5 5 5 5│
└───────┘
</pre><pre class=input4 line=658>      8 ⎕CR ⊂B</pre><pre class=output4 line=730>┌─────────┐
│┌→──────┐│
│↓5 5 5 5││
││5 5 5 5││
││5 5 5 5││
│└───────┘│
└ϵ────────┘
</pre><tr><td class=tab1><b>Pick</b><br>Z is a nested sub-value of B, whose position in B is determined by A.
Every item of A corresponds to a nesting level of B.<td class=tab12><pre class=input4 line=658>      8 ⎕CR  S←2 3ρ'AB' 'CD' 'EF' 'GH' 'IJ' 'KL'</pre><pre class=output4 line=730>┌→─────────────┐
↓┌→─┐ ┌→─┐ ┌→─┐│
││AB│ │CD│ │EF││
│└──┘ └──┘ └──┘│
│┌→─┐ ┌→─┐ ┌→─┐│
││GH│ │IJ│ │KL││
│└──┘ └──┘ └──┘│
└ϵ─────────────┘
</pre><pre class=input4 line=658>      (1 3) 2 ⊃ S   ⍝ (1 3) selects 'EF' from S, 2 selects 'F' from 'EF'</pre><pre class=output4 line=730>F
</pre><pre class=input4 line=658>      (⊃S[1;3])[2]  ⍝ the same.</pre><pre class=output4 line=730>F
</pre><td class=tab3>⊃<td class=tab4><b>Disclose</b><br>Z is the elements of B,
with nested sub-values
replaced by arrays padded
to the same common size<td class=tab5><pre class=input4 line=658>      8 ⎕CR B←2 2⍴'One' 'Two' 'Three' 'Four'</pre><pre class=output4 line=730>┌→─────────────┐
↓┌→──┐   ┌→──┐ │
││One│   │Two│ │
│└───┘   └───┘ │
│┌→────┐ ┌→───┐│
││Three│ │Four││
│└─────┘ └────┘│
└ϵ─────────────┘
</pre><pre class=input4 line=658>      8 ⎕CR ⊃ B</pre><pre class=output4 line=730>┌→────┐
↓One  │
│Two  │
│     │
│Three│
│Four │
└─────┘
</pre><tr><td class=tab1><b>Rotate</b><br>Z is B rotated according to A<td class=tab12><pre class=input4 line=658>      ⊢B←3 5⍴⍳5</pre><pre class=output4 line=730>1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
</pre><pre class=input4 line=658>      1 2 3⌽B       ⍝ rotate along the last axis (columns)</pre><pre class=output4 line=730>2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
</pre><pre class=input4 line=658>      ¯1 ¯2 ¯3⌽B    ⍝ rotate backwards along the last axis (columns)</pre><pre class=output4 line=730>5 1 2 3 4
4 5 1 2 3
3 4 5 1 2
</pre><pre class=input4 line=658>      ⊢B←3/⍪⍳5</pre><pre class=output4 line=730>1 1 1
2 2 2
3 3 3
4 4 4
5 5 5
</pre><pre class=input4 line=658>      1 2 3⊖B       ⍝ rotate along the first axis (rows)</pre><pre class=output4 line=730>2 3 4
3 4 5
4 5 1
5 1 2
1 2 3
</pre><td class=tab3>⊖<br>⌽<td class=tab4><b>Reverse</b><br>Z is B with the items reversed along the first or last axis resp.<td class=tab5><pre class=input4 line=658>      ⌽1 2 3 4 5</pre><pre class=output4 line=730>5 4 3 2 1
</pre><tr><td class=tab1><b>Transpose (General)</b><br>Z is B transposed according to A.<br>A is a vector of
numbers in<br>1 2 3...⌈/A (or in<br>0 1 2..., if ⎕IO←0).<br><br>Permutations A (of
⍳⍴⍴B) permute the
axes of B.<br><br>Repeated items in A
select diagonals in
B and reduce the rank
of the result.<td class=tab12><pre class=input4 line=658>      ⊢N234←10 ⊥¨ ⍳2 3 4</pre><pre class=output4 line=730>111 112 113 114
121 122 123 124
131 132 133 134

211 212 213 214
221 222 223 224
231 232 233 234
</pre><pre class=input4 line=658>      1 3 2⍉N234</pre><pre class=output4 line=730>111 121 131
112 122 132
113 123 133
114 124 134

211 221 231
212 222 232
213 223 233
214 224 234
</pre><pre class=input4 line=658>      1 1 2⍉N234   ⍝ axis 1 repeated</pre><pre class=output4 line=730>111 112 113 114
221 222 223 224
</pre><td class=tab3>⍉<td class=tab4><b>Transpose (Reverse Axes)</b><br>Z is B transposed so that the order
of axes is reversed. Z←⍉B ←→ (⌽⍳⍴B)⍉B<td class=tab5><pre class=input4 line=658>      ⊢N234←10 ⊥¨ ⍳2 3 4</pre><pre class=output4 line=730>111 112 113 114
121 122 123 124
131 132 133 134

211 212 213 214
221 222 223 224
231 232 233 234
</pre><pre class=input4 line=658>      ⍉ N234</pre><pre class=output4 line=730>111 211
121 221
131 231

112 212
122 222
132 232

113 213
123 223
133 233

114 214
124 224
134 234
</pre><tr><td class=tab1><b>Intersection</b><br>Z is the elements of A that are also in B<td class=tab12><pre class=input4 line=658>      1 2 3 4 5 6 ∩ 3 4 5 6 7 8</pre><pre class=output4 line=730>3 4 5 6
</pre><td class=tab3>∩<td class=tab4>N/A<td class=tab5><pre class=input4 line=658>      ∩ 3 4 5 6 7 8</pre><pre class=errput4 line=741>VALENCE ERROR
      ∩3 4 5 6 7 8
      ^
</pre><tr><td class=tab1><b>Compress</b><br>Z is the elements of B with B[i] repeated A[i] times<td class=tab12><pre class=input4 line=658>      1 2 3 4 5 / 'ABCDE'<pre class=output4 line=730>ABBCCCDDDDEEEEE
</pre>1 2 3 4 5 / '1A' '2B' '3C' '4D' '5E'</pre><pre class=output4 line=730> 1A 2B 2B 3C 3C 3C 4D 4D 4D 4D 5E 5E 5E 5E 5E
</pre><td class=tab3>/<br>⌿<td class=tab4>N/A (note that f/B is an operator that takes one value argument)<td class=tab5><pre class=input4 line=658>      / 'ABCDE'</pre><pre class=errput4 line=741>SYNTAX ERROR
      /'ABCDE'
      ^
</pre><tr><td class=tab1><b>Expand</b><br>A[i] is 0 or 1; if 1 then Z[i] is B[i⌷+\A] or ↑0⍴B otherwise.<td class=tab12><pre class=input4 line=658>      1 0 1 0 0 1\1 2 3   ⍝ 1 at 1, 2 at 3, and 3 at 6; ↑0⍴B is 0<pre class=output4 line=730>1 0 2 0 0 3
</pre>1 0 1 0 0 1 \ 'ABC' ⍝ A at 1, B at 3, and C at 6; ↑0⍴B is ' '</pre><pre class=output4 line=730>A B  C
</pre><td class=tab3>\<br>⍀<td class=tab4>N/A (note that f\B is an operator that takes one value argument)<td class=tab5><pre class=input4 line=658>      \ 'ABCDE'</pre><pre class=errput4 line=741>SYNTAX ERROR
      \'ABCDE'
      ^
</pre></table><h4><a id=CH_3.4.11></a>3.4.11 List of Built-in Monadic APL Operators</h4>A monadic APL operator OP1 takes 2 or 3 arguments in the following order:<ul><li>a left value <b>A</b> (mandatory or optional, depending on the operator),<li>a mandatory left function argument <b>f</b> (followed by the operator itself)<li>a mandatory right value <b>B</b>.</ul><table class=table1 cellspacing=0 cellpadding=0><tbody><tr><th class=tab12 colspan=2>Used with 2 Value Arguments A and B: Z←A f OP1 B<th class=tab3>OP1<th class=tab45 colspan=2>Used with 1 Value Argument B: Z←f OP1 B<tr><th class=tab1>Name/Description<th class=tab2>Example(s)<th class=tab3>&nbsp;<th class=tab4>Name/Description<th class=tab5 colspan=5>Example(s)<tr><td class=tab1><b>Reduce N-wise</b><br>Like <b>f/B</b> and <b>f⌿B</b> except that <b>f</b> is applied to groups
C<sub>1</sub> C<sub>2</sub> ... C<sub>n</sub>.
Each group C<sub>n</sub> has A consecutive items of B and starts at position
i of the axis along which the N-wise reductions are computed.<td class=tab12><pre class=input4 line=658>      ⊢R←1 2 3 4 5 6<pre class=output4 line=730>1 2 3 4 5 6
</pre>4 +/ R<pre class=output4 line=730>10 14 18
</pre>+/R[1 2 3 4] ⍝ group C₁ ←→ Z[1]<pre class=output4 line=730>10
</pre>+/R[2 3 4 5] ⍝ group C₂ ←→ Z[2]<pre class=output4 line=730>14
</pre>+/R[3 4 5 6] ⍝ group C₃ ←→ Z[3]</pre><pre class=output4 line=730>18
</pre><pre class=input4 line=658>      ⊢R←2 6⍴⍳12      ⍝ ⍴⍴R &gt; 1<pre class=output4 line=730>1 2 3  4  5  6
7 8 9 10 11 12
</pre>4 +/ R</pre><pre class=output4 line=730>10 14 18
34 38 42
</pre><td class=tab3>/<br>⌿<td class=tab4><b>Reduce</b><br><b>Z</b> is computed by applying <b>f</b> repeatedly along the last axis
of B, i.e. Z←[;;1] f B[;;2] f ... f B[;;N] (the number of semicolons
is ¯1+⍴⍴B and N←¯1↑⍴B). f⌿B is the same except that f is computed
along the first axis of B.<td class=tab5><pre class=input4 line=658>      2 3⍴⍳6      ⍝ example argument B</pre><pre class=output4 line=730>1 2 3
4 5 6
</pre><td class=tab5><pre class=input4 line=658>      +/ 2 3⍴⍳6   ⍝ +/ is the sum of row elements</pre><pre class=output4 line=730>6 15
</pre><td class=tab5><pre class=input4 line=658>      +⌿ 2 3⍴⍳6   ⍝ +⌿ is the sum of column elements</pre><pre class=output4 line=730>5 7 9
</pre><tr><td class=tab1>N/A<td class=tab12><pre class=input4 line=658>      2 +\ 1 2 3 4</pre><pre class=errput4 line=741>VALENCE ERROR
      2+\1 2 3 4
      ^ ^
</pre><td class=tab3>\<br>⍀<td class=tab4><b>Scan</b><br>Z←f\B or Z←f⍀B is like Z←f/B or Z←f⌿B resp. except that the partial
results of the different invocations of function f are not discarded
but included in the result Z.<td class=tab5><pre class=input4 line=658>      +\ 1 2 3 4 5   ⍝ 1, 1+2, 1+2+3, 1+2+3+4, 1+2+3+4+5</pre><pre class=output4 line=730>1 3 6 10 15
</pre><tr><td class=tab1><b>Commute</b><br>Z is B f A (the arguments A and B are exchanged)<td class=tab12><pre class=input4 line=658>      2 ÷ 1</pre><pre class=output4 line=730>2
</pre><pre class=input4 line=658>      2 ÷⍨ 1</pre><pre class=output4 line=730>0.5
</pre><td class=tab3>⍨<td class=tab4><bo duplicate<br>Z is B f B (the single argument B is duplicated)</bo><td class=tab5><pre class=input4 line=658>      ×⍨ 1 2 3 4   ⍝ squares</pre><pre class=output4 line=730>1 4 9 16
</pre><tr><td class=tab1><b>Each (dyadic)</b><br>Z[i] is A[i] f B[i] (f is called dyadically
for all corresponding items of A and B)<td class=tab12><pre class=input4 line=658>      8 ⎕CR  1 2 3 ,10 20 30</pre><pre class=output4 line=730>┌→─────────────┐
│1 2 3 10 20 30│
└──────────────┘
</pre><pre class=input4 line=658>      8 ⎕CR  1 2 3 ,¨10 20 30</pre><pre class=output4 line=730>┌→───────────────────┐
│┌→───┐ ┌→───┐ ┌→───┐│
││1 10│ │2 20│ │3 30││
│└────┘ └────┘ └────┘│
└ϵ───────────────────┘
</pre><td class=tab3>f¨<td class=tab4><b>Each (monadic)</b><br>Z[i] is f B[i] (f called monadically for every item B[i] of B)<td class=tab5><pre class=input4 line=658>      8 ⎕CR , 1 2 3</pre><pre class=output4 line=730>┌→────┐
│1 2 3│
└─────┘
</pre><pre class=input4 line=658>      8 ⎕CR ,¨ 1 2 3</pre><pre class=output4 line=730>┌→──────────┐
│┌→┐ ┌→┐ ┌→┐│
││1│ │2│ │3││
│└─┘ └─┘ └─┘│
└ϵ──────────┘
</pre></table><h4><a id=CH_3.4.12></a>3.4.12 List of Built-In Dyadic APL Operators</h4>A dyadic APL operator OP2 takes 3 or 4 arguments in the following order:<ul><li>a left value <b>A</b> (mandatory or optional, depending on the operator),<li>a mandatory function argument <b>f</b>, (followed by the operator itself)<li>a mandatory function argument <b>g</b>, and<li>a mandatory right value <b>B</b>.</ul><table class=table1 cellspacing=0 cellpadding=0><tbody><tr><th class=tab12 colspan=2>Used with 2 Value Arguments A and B: Z←A f OP2 g B<th class=tab3>OP2<th class=tab45 colspan=2>Used with 1 Value Argument B: Z←f OP2 g B<tr><th class=tab1>Name/Description<th class=tab2>Example(s)<th class=tab3>&nbsp;<th class=tab4>Name/Description<th class=tab5 colspan=5>Example(s)<tr><td class=tab1><b>Inner Product</b><br>Z[i;j] is f / A[i] g B[j]. Row A[;j] is multiplied
with column B[i;] and the resulting vector V is
then f-reduced to give the scalar Z[i;j] (enclosed
if necessary to yield a scalar).<br>For simple numeric matrices A and B this is
the "matrix multiplication" known from linear
algebra.<td class=tab12><pre class=input4 line=658>      ⊢A←2 2⍴1 2 3 4</pre><pre class=output4 line=730>1 2
3 4
</pre><pre class=input4 line=658>      ⊢B←2 2⍴1 2 3 4</pre><pre class=output4 line=730>1 2
3 4
</pre><pre class=input4 line=658>      ⊢A +.× B</pre><pre class=output4 line=730> 7 10
15 22
</pre><td class=tab3>f.g<td class=tab4>Monadic f.g throws an error however ⍨ can be used to duplicate B<td class=tab5><pre class=input4 line=658>      +.× 2 2⍴1 2 3 4</pre><pre class=errput4 line=741>VALENCE ERROR
      +.×2 2⍴1 2 3 4
      ^ ^
</pre><pre class=input4 line=658>      +.×⍨ 2 2⍴1 2 3 4</pre><pre class=output4 line=730> 7 10
15 22
</pre><tr><td class=tab1><b>Outer Product</b><br>Z[i;j] is A[i] g B[j]. ⍴Z ←→ (⍴A),⍴B)<td class=tab12><pre class=input4 line=658>      B ∘.× B←⍳10</pre><pre class=output4 line=730> 1  2  3  4  5  6  7  8  9  10
 2  4  6  8 10 12 14 16 18  20
 3  6  9 12 15 18 21 24 27  30
 4  8 12 16 20 24 28 32 36  40
 5 10 15 20 25 30 35 40 45  50
 6 12 18 24 30 36 42 48 54  60
 7 14 21 28 35 42 49 56 63  70
 8 16 24 32 40 48 56 64 72  80
 9 18 27 36 45 54 63 72 81  90
10 20 30 40 50 60 70 80 90 100
</pre><td class=tab3>∘.g<td class=tab4>Monadic ∘.f throws an error however ⍨ can be used to duplicate B<td class=tab5><pre class=input4 line=658>      ∘.× ⍳5</pre><pre class=errput4 line=741>VALENCE ERROR
      ∘.×⍳5
      ^  ^
</pre><pre class=input4 line=658>      ∘.×⍨ ⍳5</pre><pre class=output4 line=730>1  2  3  4  5
2  4  6  8 10
3  6  9 12 15
4  8 12 16 20
5 10 15 20 25
</pre><tr><td class=tab1><b>Rank</b><br><b>Z←A f ⍤ y B</b> is
function <b>f</b> applied to the
rank-<b>a</b> cells of <b>A</b>
and the rank-<b>b</b> cells of <b>B</b>
(with <b>a</b> and <b>b</b> defined
by <b>y</b>, see monadic case).<br><br>This dyadic case uses
only <b>a</b> and <b>b</b> of
<b>y←m a b</b>; the first item <b>m</b>
is used in the monadic case.<br>The intention of this somewhat
confusing definition was apparently
the use of the same <b>y</b>
in the monadic and dyadic cases.
However, a two item <b>y←a b</b>
(with <b>a</b> ignored in the monadic
case) would have been more plausible.<td class=tab12><pre class=input4 line=658>      0 1 2⌽⍤0 1 'ABC'</pre><pre class=output4 line=730>ABC
BCA
CAB
</pre><td class=tab3>⍤<td class=tab4><b>Rank</b><br><b>Z←f ⍤ y B</b> is
function <b>f</b> applied
to the rank-<b>m</b> cells
of <b>B</b> (where <b>m</b> is
defined by <b>y</b>, see
below.).<br><br>The <b>rank-v cells</b> of
a value <b>V</b>, <b>v≤⍴⍴V</b>,
is <b>V</b> enclosed along its
<b>v</b> lower axes, i.e.
<b>⊂[(-v)↑⍴V] V</b><br><br><i>Conceptually</i> is <b>y</b>
a 3 item integer vector:
<b>y ← m a b</b>.
Shorter <b>y</b> are expanded:<br><br><b>y←m</b> ←→ <b>y←m m m</b>
<b>y←a b</b> ←→ <b>y←b a b</b><br><br>This monadic case uses only
the first item <b>m</b> of <b>y</b>,
but not <b>a</b> or <b>b</b>.<td class=tab5><pre class=input4 line=658>      y←0 ◊ ⍳⍤y 1 2 3</pre><pre class=output4 line=730>1 0 0
1 2 0
1 2 3
</pre><pre class=input4 line=658>      ⍝ ISO standard 13751 uses arrays like N233 below,
   ⍝ whose items are unique and reflect their position
   ⍝ in the array That is, e.g. N233[i;j;k] ←→ ijk
   ⍝
   ⎕ ← N233 ← 10 ⊥¨ ⍳2 3 3</pre><pre class=output4 line=730>111 112 113
121 122 123
131 132 133

211 212 213
221 222 223
231 232 233
</pre><pre class=input4 line=658>      (,⍤2) N233</pre><pre class=output4 line=730>111 112 113 121 122 123 131 132 133
211 212 213 221 222 223 231 232 233
</pre><pre class=input4 line=658>      ⍳⍤0 1 2 3     ⍝ ambiguous, see below</pre><pre class=output4 line=730>1 2 3
</pre><pre class=input4 line=658>      (⍳⍤0) 1 2 3   ⍝ y B ←→ (0) (1 2 3)</pre><pre class=output4 line=730>1 0 0
1 2 0
1 2 3
</pre><pre class=input4 line=658>      (⍳⍤0 1) 2 3   ⍝ y B ←→ (0 1) (2 3)</pre><pre class=output4 line=730> 1 1  1 2  1 3
 2 1  2 2  2 3
</pre><pre class=input4 line=658>      (⍳⍤0 1 2) 3   ⍝ y B ←→ (0 1 2) (3)</pre><pre class=output4 line=730>1 2 3
</pre><tr><td class=tab1><b>Power Operator</b><br><b>Z←A f ⍣ N B</b> (N > 0):<br>repeat: Z←B←A f B<br>(repeats N times).<br><br><b>Z←A f ⍣ N B</b> (N &lt; 0):<br>repeat: Z←B←A f<sup>-1</sup> B<br>(repeats -N times).<br><br><b>Z←A f ⍣ g B</b><br>with function <b>g</b>:
repeat: Z←B←A f B<br>until (A f B) g B.<td class=tab12><pre class=input4 line=658>      2 (×⍣ 5) 1   ⍝ 2 × 2 × 2 × 2 × 2 × 1</pre><pre class=output4 line=730>32
</pre><pre class=input4 line=658>      2 (×⍣ ¯5) 1   ⍝ ((((1 ÷ 2) ÷ 2) ÷ 2) ÷ 2) ÷ 2</pre><pre class=output4 line=730>0.03125
</pre><pre class=input4 line=658>      2 (-⍣≤)  6.4   ⍝ (2 - 6.4) = ¯4.4 and 4.4 ≤ 6.4</pre><pre class=output4 line=730>¯4.4
</pre><td class=tab3>⍣<td class=tab4><b>Power Operator</b><br><b>Z←f ⍣ N B</b> (N > 0):<br>repeat: Z←B←f B<br>(repeats N times).<br><br><b>Z←f ⍣ N B</b> (N &lt; 0):<br>repeat: Z←B←f<sup>-1</sup> B<br>(repeats -N times).<br><br><b>Z←f ⍣ g B</b><br>with function <b>g</b>:
repeat: Z←B←f B<br>until (f B) g B.<td class=tab5><pre class=input4 line=658>      (-⍣3) 5    ⍝ - - - 5</pre><pre class=output4 line=730>¯5
</pre><pre class=input4 line=658>      (-⍣¯3) 5   ⍝ -<sup>-1</sup> is +</pre><pre class=output4 line=730>5
</pre></table><br><br><b>Notes</b>: The outer product is considered a dyadic operator here (and also
in the APL standard), even though it has only one functional argument and
not two. If it were a monadic operator then the function argument g would
have to appear left of the operator symbol (.) rather than right of it.
In a way one can consider the outer product as the inner product with '∘'
being the identity function.<br><br>The ISO standard defines f⍤y as dyadic operator (with a left (function)
argument f and right (numeric) argument y. y is a numeric vector with
1, 2, or 3 elements, which may be ambiguous in certain cases.<h4><a id=CH_3.4.13></a>3.4.13 Functions and Operators with Axis Argument</h4>As we have seen above, some built-in functions and operators have variants
that operate along the first or along the last axis. For example:<pre class=input_T line=664>      ⊢A←2 3 ⍴'A'</pre><pre class=output1 line=732>AAA
AAA
</pre><pre class=input_ line=665>      ⊢B←2 3⍴'b'</pre><pre class=output1 line=732>bbb
bbb
</pre><pre class=input_ line=665>      A,B   ⍝ catenate along last axis</pre><pre class=output1 line=732>AAAbbb
AAAbbb
</pre><pre class=input_ line=665>      A⍪B   ⍝ catenate along first axis</pre><pre class=output line=731>AAA
AAA
bbb
bbb
</pre>For built-in functions and operators the symbol for the variant that
works along the first axis is the symbol for the variant that works along
the last axis but with a '-' overstrike. These days APL uses a keyboard
layout where every APL character can be entered with the help of the
Ctrl-key or with the Alt-key, but in the early days of APL the character
'⍪' was produced by typing ',' then backspace (which moved the input cursor
back over the ',' just typed) and finally '-'. On a standard ASCII terminal
this 3 character sequence would have replaced ',' with '-' but on an APL
terminal it instead would have combined the ',' and the '-' resulting in
the overstrike character '⍪'.
Coming back to our axis arguments topic: Those built-in functions that
can operate along the first or along the last axis can also operate along
any other axis. The desired axis is provided after the function or operator
symbol enclosed in brackets:<br><pre class=input_T line=664>      ⊢A←2 3 4⍴'A'</pre><pre class=output1 line=732>AAAA
AAAA
AAAA

AAAA
AAAA
AAAA
</pre><pre class=input_ line=665>      ⊢B←2 3 4⍴'b'</pre><pre class=output1 line=732>bbbb
bbbb
bbbb

bbbb
bbbb
bbbb
</pre><pre class=input_ line=665>      A,B   ⍝ catenate along last axis</pre><pre class=output1 line=732>AAAAbbbb
AAAAbbbb
AAAAbbbb

AAAAbbbb
AAAAbbbb
AAAAbbbb
</pre><pre class=input_ line=665>      A⍪B   ⍝ catenate along first axis</pre><pre class=output1 line=732>AAAA
AAAA
AAAA

AAAA
AAAA
AAAA

bbbb
bbbb
bbbb

bbbb
bbbb
bbbb
</pre><pre class=input_ line=665>      A,[1]B   ⍝ catenate along first axis</pre><pre class=output1 line=732>AAAA
AAAA
AAAA

AAAA
AAAA
AAAA

bbbb
bbbb
bbbb

bbbb
bbbb
bbbb
</pre><pre class=input_ line=665>      A,[2]B   ⍝ catenate along middle axis</pre><pre class=output1 line=732>AAAA
AAAA
AAAA
bbbb
bbbb
bbbb

AAAA
AAAA
AAAA
bbbb
bbbb
bbbb
</pre><pre class=input_ line=665>      A,[3]B   ⍝ catenate along last axis</pre><pre class=output line=731>AAAAbbbb
AAAAbbbb
AAAAbbbb

AAAAbbbb
AAAAbbbb
AAAAbbbb
</pre><br>The axis can be given as a numeric literal as above, but also as a
variable whose value is a number indicating a valid axis of the arguments.<h4><a id=CH_3.4.14></a>3.4.14 System Functions</h4>The built-in APL functions that we have introduced so far were represented
by a single APL glyph (UCS character). These functions are commonly referred
to as "primitive APL functions" (or operators) or simply "APL primitives".
There is another group of built-in APL functions called "System Functions"
which are used in the same way as primitives. The distinction between APL
primitives and system functions is somewhat arbitrary and not only result
from a lack of suitable APL glyphs or keyboard keys but allow an arbitrary
number to be defined. The few differences between primitives and system
functions are:<br><ul><li>a primitive is denoted by a single UCS character while a system function
is denoted by the character ⎕ followed by one or more characters A-Z
or a-z (see chapter "Names of System Functions and System Variables"
above)<li>The function computed by APL primitives is essentially the same on
different APL interpreters while the system functions (especially
their presence or absence) may differ considerably between different
APL interpreters.<li>APL primitives compute APL values from other APL values while system
functions typically provide an interface to the resources of the
underlying operating system on which the interpreter runs.</ul><br>For a quick tour of GNU APL the details of the GNU APL system functions
are far to extensive and we refer the reader to the <b>GNU APL info manual</b>
where the GNU APL specific system functions are described in more detail,
and to the ISO standard 13751 for more common system functions. Note that
some system functions are obsolete these days but maintained only for
backward-compatibility with older (i.e. APL1) interpreters.<br><h5><a id=CH_3.4.14.1></a>3.4.14.1 Z ← ⎕AF B : Atomic Function</h5>Monadic, obsolete. In a pure Unicode interpreter like GNU APL <b>⎕AF B</b>
seems to be the same as <b>⎕UCS B</b>.<h5><a id=CH_3.4.14.2></a>3.4.14.2 Z ← A ⎕AT B : Attributes</h5>Dyadic: For a (user-defined) name <b>FOO</b> which designates an existing
defined function or variable, the expression <b>A ⎕AT 'FOO'</b> yields a
numeric vector with attributes from a category that is defined by <b>A</b>:<ul><li>A=1: result type, function and operator valences<li>A=2: creation time, valences<li>A=3: execution properties<li>A=4: object sizes (CDR)</ul>Note that the name <b>FOO</b> is quoted to make it a character vector. ⎕AT also
accepts a character matrix if the attributes of multiple names shall be
obtained.<h5><a id=CH_3.4.14.3></a>3.4.14.3 Z ← A ⎕CR B : Character Representation</h5>Monadic: For a (user-defined) name <b>FOO</b> which designates an existing
defined function or operator, the expression <b>⎕CR 'FOO'</b> yields the
character representation for that name. The character representation of a
function is a character matrix with one line for every line (including
the header line) of the function or operator.<br><br>Dyadic: As a GNU APL specific feature, dyadic <b>A ⎕CR 'FOO'</b> is one of
over 40 different conversion functions. The integer scalar A ≥ 0 selects
one of these functions. <b>⎕CR ⍬</b> and <b>⎕CR ''</b> display slightly different
lists of the functions implemented so far.<h5><a id=CH_3.4.14.4></a>3.4.14.4 Z ← ⎕DL B : Delay</h5>Monadic: <b>⎕DL N</b> pauses the operation of the interpreter for N seconds.<h5><a id=CH_3.4.14.5></a>3.4.14.5 Z ← A ⎕DLX B : Donald Knuth's Dancing Links</h5>Dyadic: <b>⎕DLX</b> implements a powerful backtracking machine known as
"Dancing links" or "Algorithm X". The algorithm was published by Donald
Knuth in 2000 and is the algorithm of choice for a class of problems that
is best soved by means of backtracking. For example the 8 tower and 8
queens problem on a chess-board or sudokus. Formally <b>⎕DLX</b> solves
the so-called "exact cover problem": given a binary matrix B, find a
subset Z of ⍳↑⍴B so that (+/[1]B[Z;]) ≡ ((¯1↑⍴B)⍴1). Less formally:
find a sub-matrix S←B[Z;] of B so that every column of S contains
exactly one 1. The left argument A of <b>A ⎕DLX B</b> controls the type
of result desired such as compute only one solution, compute all solutions,
etc.<h5><a id=CH_3.4.14.6></a>3.4.14.6 Z ← A ⎕EA B : Execute Alternate</h5>Dyadic: <b>A ⎕EA B</b> computes <b>⍎B</b> and, if that fails, computes <b>⍎A</b>.
A and B are character vectors containing APL expressions. The result of
<b>A ⎕EA B</b> is the result of <b>⍎A</b> if it succeeds, otherwise the result of
<b>⍎B</b>. If <b>⍎B</b> succeeds then <b>⍎A</b> is not computed so that either
<b>⍎B</b> or <b>⍎A</b> is being computed.<h5><a id=CH_3.4.14.7></a>3.4.14.7 Z ← A ⎕EB B : Execute Both</h5>Dyadic: <b>A ⎕EB B</b> computes <b>⍎B</b> and then <b>⍎A</b>. Errors in <b>⍎B</b>
are ignored, so that <b>⍎B</b> and <b>⍎A</b> are both computed. Typically
<b>⍎A</b> is an error handler for the case where <b>⍎B</b> has failed, e.g.
for providing a replacement for the missing result of <b>⍎A</b>.
<b>⎕EB</b> is a GNU APL specific feature.<h5><a id=CH_3.4.14.8></a>3.4.14.8 Z ← ⎕EC B : Execute Controlled</h5>Monadic: <b>⎕EC B</b> computes <b>⍎B</b> but does not interupt the APL
interpreter when an error occurs. Instead the 3-element result vector
<b>(Z1 Z2 Z3)←⎕EC B</b> indicates the type of result:<ul><li>Z1=0: Error, e.g. 2+'A'<li>Z1=1: Value, e.g. 2+2<li>Z1=2: Committed Value, e.g. A←2+2<li>Z1=3: No Value, e.g. FOO with FOO returning no result<li>Z1=4: Branch, e.g. → 2<li>Z1=5: Escape, e.g. →</ul><b>Z2</b> is the result that <b>⎕ET</b> (see below) would have had if <b>⍎B</b>
were computed without <b>⎕EC</b>. When computed with <b>⎕EC</b> then <b>⎕ET</b>
is not affected.
<b>Z3</b> is the actual result of <b>⍎B</b>:<ul><li>Z1=0: ⎕EM (see below)<li>Z1=1: e.g. 4 for 2+2<li>Z1=2: e.g. 4 for A←2+2<li>Z1=3: 0 0⍴0<li>Z1=4: e.g. 2 for → 2<li>Z1=5: 0 0⍴0</ul><h5><a id=CH_3.4.14.9></a>3.4.14.9 Z ← ⎕ENV B : ENvironment Variables</h5>Monadic: GNU APL feature: return the names and values of the environment
variables in the operating system at the point in time when the GNU APL
interpreter was started. The argument <b>B</b> of <b>⎕ENV B</b> is a prefix
for the names of the environment variables that shall be returned.<h5><a id=CH_3.4.14.10></a>3.4.14.10 Z ← A ⎕ES B : Event Simulate</h5>Nomadic: Programmatically simulate an error event. For testing error
handlers. Monadic <b>⎕ES B</b> is <b>⎕EM ⎕ES B</b> or <b>B ⎕ES ⎕ET</b> depending
on B being either a character vector (event message) or a 2-item integer
vector (event type).<h5><a id=CH_3.4.14.11></a>3.4.14.11 Z ← ⎕EX B : EXpunge</h5>Monadic: Argument <b>B</b> of <b>⎕EX B</b> specifies one or more name(s) of
variables, functions, or operators that shall be erased. For each name, the
corresponding result item is 1 on success or 0 on error.<h5><a id=CH_3.4.14.12></a>3.4.14.12 Z ← A ⎕FFT B : Fast Fourier Transform</h5>Nomadic. Compute the fast fourier transform of real or complex <b>B</b>.
The optional argument <b>A</b> controls details such as a window function
to be used for the FFT.<h5><a id=CH_3.4.14.13></a>3.4.14.13 ⎕FIO[X] B : File I/O functions</h5>Dyadic: Similar to <b>A ⎕CR B</b> above, <b>A ⎕FIO B</b> is a collection of
over 60 different (sub-) functions. Dyadic <b>A ⎕FIO B</b> has a mandatory
axis argument <b>X</b> which is an integer scalar X ≥ 0 that selects
one of these sub-functions. The sub-function <b>⎕FIO[X]</b> is then monadic,
dyadic or nomadic.
As a matter of convenience, the functions <b>A ⎕FIO ⍬</b> and <b>A ⎕FIO ""</b>
(i.e. without an axis argument) display lists of the functions implemented
by <b>A ⎕FIO[X] B</b> so far in different formats.
The functions in <b>⎕CR</b> are conversion functions which means that they
transform one APL value into another APL value. As a consequence each
conversion function is monadic and the left argument <b>B</b> is the value
that is being converted.
In contrast, the functions in <b>⎕FIO</b> constitue an interface to the
underlying operating system and every function in <b>⎕FIO</b> corresponds
to a C function in library libc. This has two consequences:<ol><li>the corresponding C function in libc has more often than not two or
more arguments. For this reason, the function number which selects
the individual function is now the numeric axis argument <b>X</b>
of <b>A ⎕FIO[X] B</b>.<li>the now unused left argument <b>A</b> has now become avaiable as another
argument for the selected function <b>⎕FIO[X]</b>. That is, all functions
<b>A ⎕CR</b> are monadic while most functions <b>⎕FIO[X]</b> are dyadic.</ol>In the early days of GNU APL there were only a few functions <b>⎕FIO[X]</b>
and distinguishing different sub-functions by means of function numbers
was already common practice (see, for example, ⎕AT above) and was adequate
as long as the number of sub-functions was small. Over the years, however,
more and more functions were added to <b>⎕FIO</b>, and the resulting
APL code became more and more difficult to read. Therefore at
some point in time a second mechanism - function names instead of function
numbers - was added. One could now, for example, write <b>⎕FIO['fopen']</b>
instead of the less intuitive <b>⎕FIO[3]</b>.<br><br>A minor flaw of the new function names was that they needed to be quoted.
This led to a third syntax variant where the function name became an
(unquoted) APL name instead of a (quoted) APL string. This is most likely
the final and most elegant syntax for <b>⎕FIO</b> where one can now write
<b>⎕FIO.fopen</b> instead of <b>⎕FIO['fopen']</b> or <b>⎕FIO[3]</b>.<h5><a id=CH_3.4.14.14></a>3.4.14.14 Z ← ⎕FX B : FiX</h5>Monadic: <b>B</b> is either a character matrix or a vector of function lines
(function header and APL code). <b>⎕FX B</b> creates a new defined APL function
(see the chapter "Defined Functions" below). With monadic ⎕FX one can therefore
create new defined APL functions at runtime.<br><br>Dyadic: As a GNU APL feature one cannot only create defined functions that
consist of lines of APL code, but also defined functions that were written
in other computer languages, most commonly in C/C++. These so-called
"native" functions are provided in terms of shared libraries that the user
must construct beforehand. In <b>A ⎕FX B</b> <b>A</b> is the file name of a
shared library file and <b>B</b> the APL name of the function implemented
in the shared library.<br><br>GNU APL is shipped with a set of templates for creating native functions
or operators that are intended as starting points for native functions
created by the user.<br><br><h5><a id=CH_3.4.14.15></a>3.4.14.15 Z ← ⎕GTK B : Gtk GUI</h5><b>⎕GTK</b> is an interface to GTK (Graphical Tool Kit) version 3. It implements
a small subset of the GTK 3 API and is intended for (and limited to)
creating simple windows on the screen, for example to request input from
the user in a more intuitive way than the old-fsshioned ⎕ and ⍞ input
variables.<h5><a id=CH_3.4.14.16></a>3.4.14.16 Z ← A ⎕JSON B : JSON parser</h5>Monadic: <b>B</b> is a text string in JSON (JavaScript Object Notation) format
which is converted to the corresponding APL value <b>Z</b>.<br><br>Dyadic: <b>B</b> is an APL value which is converted to the corresponding JSON
string. <b>A</b> controls some aspect of this conversion, for example to read
the JSON data string from a file rather than from an APL text vector.<h5><a id=CH_3.4.14.17></a>3.4.14.17 Z ← A ⎕MAP B : MAP (replace) ravel elements</h5><b>Z</b> is <b>B</b> but with every occurance of ravel <b>A[j;1]</b> replaced
with <b>A[j;2]</b>.
The same can be achieved with <b>⎕RE</b>, but <b>⎕MAP</b> is optimized for this
kind of 1:1 replacement while <b>⎕RE</b> is more powerful but slower.<h5><a id=CH_3.4.14.18></a>3.4.14.18 Z ← ⎕INP B : INPut from script</h5><b>⎕INP</b> is an early attempt to handle multi-line literals in GNU APL.
It has been obsoleted by GNU APL multi-line literals but is still used
internally. <b>⎕INP</b> should not be used in ordinary APL programs.<h5><a id=CH_3.4.14.19></a>3.4.14.19 Z ← ⎕NA B : Name Association</h5>Obsolete. Throws a "NOT YET IMPLEMENTED" exception when called. This function
ony exists so that workspaces from IBM APL2 that use it can be imported into
GNU APL.<h5><a id=CH_3.4.14.20></a>3.4.14.20 Z ← ⎕NC B : Name Class</h5><b>B</b> is a matrix of APL names and <b>Z</b> is the current category for every
name:<ul><li>¯1: name B is not a valid APL name (i.e. B is malformed)<li>0: name B is a valid APL name but not used<li>1: name B denotes a label (in a defined function)<li>2: name B denotes a variable<li>3: name B denotes a defined function<li>4: name B denotes a defined operator<li>5: name B denotes a system variable (NOTE: only in GNU APL)<li>6: name B denotes a system function (NOTE: only in GNU APL)</ul><h5><a id=CH_3.4.14.21></a>3.4.14.21 Z ← A ⎕NL B : Name List</h5><b>Z</b> is a matrix of all (user-defined) names where: every name begins with
an APL string <b>A</b> and has one of the name classes in numeric vector <b>B</b>.<h5><a id=CH_3.4.14.22></a>3.4.14.22 Z ← A ⎕PLOT B : Plot a Value</h5>Monadic: Simple plot (without attributes). The value <b>B</b> is plotted
(i.e. displayed in a separate window) with default parameters for colors,
line and point sizes, etc.<br><br>Dyadic: Simple plot (with attributes). The value <b>B</b> is plotted with
user-defined attributes in <b>A</b>.<h5><a id=CH_3.4.14.23></a>3.4.14.23 Z ← A ⎕PNG B : Process PNG files and Pixel Images</h5>Monadic:
Z ← ⎕PNG B with string B: Convert PNG file B into an array of color planes.
monochrome images have one color plane while RGB images have 3 color planes
(red, green, and blue). All images may have an additional opacity plane
(aka. alpha channel).<br><br>Z[;y;x] is the pixel at position (x, y) in the images, x counting from
left to right and y from top to bottom.<br><br>Z[1;;] is the gray plane for monochrome (grayscale) images and the red
plane for RGB or RGBA images.<br><br>Z[2;;] is the alpha channel for monochrome (grayscale) images with alpha
channel and the green plane for RGB or RGBA images (unless 2 &lt; ↑⍴Z).<br><br>Z[3;;] is the blue plane for RGB or RGBA image (unless 3 &lt; ↑⍴Z).<br><br>Z[4;;] is the alpha channel RGBA images (unless 4 &lt; ↑⍴Z).<br><br>Z ← ⎕PNG B 3-dimensional array as returned above: Display the pixel array
B in a window on the screen.<br><br>Dyadic:
Z ← A ⎕PNG B : Write pixel array B to file named A.<h5><a id=CH_3.4.14.24></a>3.4.14.24 Z ← A ⎕RE B : Regular expression</h5>Dyadic: <b>Z</b> is <b>B</b> processed according to regular expression <b>A</b>.
<b>⎕RE</b> is an interface to <b>libpcre</b> (where pcre stands for
Perl-compatible regular expression) and the format of <b>A</b> is described
in the different man pages shipped with libpcre.<h5><a id=CH_3.4.14.25></a>3.4.14.25 Z ← A ⎕RVAL B : Random APL value</h5>APL provides the primitive <b>? B</b> which returns an array of (pseudo-)
random integers. <b>A ⎕RVAL B</b> generalizes this concept by computing
(pseudo-) random APL values instead of pseudo-random integers. That
means that not only the raw items of Z but also the shape, depth, and
types of the random values is chosen at random.
Monadic: <b>⎕RVAL B</b> produces the next random value.
Dyadic: <b>A ⎕RVAL B</b> controls the parameters (probablities) for subsequent
calls of monadic <b>⎕RVAL B</b>. The numeric scalar <b>A</b> specifies which
parameter shall be specified:<ul><li>A=0: change the random number generator state<li>A=1: change the probabilities for ranks<li>A=2: change the probabilities for shapes<li>A=3: change the probabilities for types (character/integer/real/complex)<li>A=4: change the probabilities for depths</ul>The current settings can be obtained by calling <b>A ⎕RVAL B</b> with <b>B</b>
a null vector (e.g., 0 ⎕RVAL ⍬).<h5><a id=CH_3.4.14.26></a>3.4.14.26 Z ← [A] ⎕SI B : State Indicator</h5>Return components of the State Indicator (see command )SI below) according
to B:<ul><li><b>⎕SI 1</b>: The name of the context. This is either the name of a defined
function, or '◊' for an immediate execution context, or '⍎' for an execute
context<li><b>⎕SI 2</b>: The line number of a defined function, or 0 for immediate
execution and execute contexts.<li><b>⎕SI 3</b>: funcion name and the line number in square brackets<li><b>⎕SI 4</b>: like 3 but augmented like for command )SIS below.<li><b>⎕SI 5</b>: The program counter (= token number) in the function.<li><b>⎕SI 6</b>: The numeric parse mode</ul>The optional left argument A is an integer scalar that selects one level of
the )SI stack; if omitted then Z contains all levels of the )SI stack.<h5><a id=CH_3.4.14.27></a>3.4.14.27 Z ← ⎕SQL[CMD] B : SQL functions</h5>⎕SQL an interface to a SQL database. See <b>info apl</b> for details.<h5><a id=CH_3.4.14.28></a>3.4.14.28 Z ← ⎕SVC B : Shared Variable Control</h5>Obsolete. Shared variables are an ancient communication concept from the
mainframe era. They are, to some extent, supported by GNU APL for
compatibility with IBM APL2. "Normal" APL variables are assigned and referenced
by the same APL interpreter instance (i.e. process). In contrast, Shared
variables are assigned and referenced by different processes, making each
shared variable a communication link between the processes.<br><br>In GNU APL the system function ⎕FIO provides communication channels that are
simpler to use than shared variables. For that reason, the system functions and
variables related to shared variables are not described in detail here. Users
who need them (to run ancient workspaces) supposedly know how they work,
and users who don't should avoid them.<h5><a id=CH_3.4.14.29></a>3.4.14.29 Z ← ⎕SVO B : Shared Variable Offer</h5>Obsolete. See ⎕SVC above.<h5><a id=CH_3.4.14.30></a>3.4.14.30 Z ← ⎕SVQ B : Shared Variable Query</h5>Obsolete. See ⎕SVC above.<h5><a id=CH_3.4.14.31></a>3.4.14.31 Z ← ⎕SVR B : Shared Variable Retraction</h5>Obsolete. See ⎕SVC above.<h5><a id=CH_3.4.14.32></a>3.4.14.32 Z ← ⎕SVS B : Shared Variable State</h5>Obsolete. See ⎕SVC above.<h5><a id=CH_3.4.14.33></a>3.4.14.33 Z ← [A] ⎕STOP B : STOP vector</h5>B is a simple string with the name of a defined function.<br>Z is the stop vector for that defined function.<br><br>if <b>A</b> is omitted then the stop vector for defined function <b>B</b> is
returned. Otherwise the stop vector for the defined function is set to <b>A</b>.
Setting the stop vector creates breakpoints at the lines in A. When such a
breakpoint is reached then APL execution stops and a new immediate execution
context is entered. The user can then examine and/or change variables,
terminate or continue the APL execution with →, execute comands, etc.<h5><a id=CH_3.4.14.34></a>3.4.14.34 Z ← A ⎕TF B : Transfer Form</h5>⎕TF converts an object in the current workspace into an APL string (and vice
versa).<br><br>The integer scalar <b>A</b> selects the format for the result <b>Z</b>; A←1
produces the <i>migration transfer form</i> while A←2 produces the
<i>extended transfer form</i> of an object.
String <b>B</b> is the name of an object (i.e. a variable, defined function,
or (with A←2) a defined operator) in the current workspace.
<b>Z</b> is a string which is a text encoding of the object that can be stored in
files, transferred over a network, etc. and that can be converted back to an
identical object in some other workspace.
The migration transfer form can only be used for old APL1 (aka. ISO standard
8485) functions and variables because it does not support APL2 (aka. ISO
standard 13751) extensions, in particular not: mixed values, nested values,
and defined operators. The format uses fixed size records of 80 bytes each,
which makes it compatible with standard 80 column Hollerith punch cards
(the now obsolete but previously prevalent storage medium for APL workspaces
in the 1960s when APL was invented). For example:<pre class=input_T line=664>      )CLEAR</pre><pre class=output1 line=732>CLEAR WS
</pre><pre class=input_ line=636>      ∇Z←A FOO B
      Z←1 2 3
      ∇
</pre><pre class=input_ line=665>      1 ⎕TF 'FOO'   ⍝ the migration transfer form of defined function FOO</pre><pre class=output1 line=732>FFOO 2 2 9 Z←A FOO BZ←1 2 3
</pre><pre class=output line=908></pre>In contrast, the extended transfer form supports these APL2 extensions. It
uses strings of APL code (primarily APL literals, ⎕FX for defined functions
and operators, and ← for variables). For example:<pre class=input_T line=664>      )CLEAR</pre><pre class=output1 line=732>CLEAR WS
</pre><pre class=input_ line=636>      ∇Z←A FOO B
      Z←1 (2 3) 'Hello'   ⍝ nested and mixed
      ∇
</pre><pre class=input_ line=665>      2 ⎕TF 'FOO'   ⍝ the extended transfer form of defined function FOO</pre><pre class=output1 line=732>⎕FX 'Z←A FOO B' 'Z←1 (2 3) ''Hello''   ⍝ nested and mixed'
</pre><pre class=output line=908></pre>If the string <b>B</b> is the result <b>Z</b> of some prior ⎕TF conversion, then
A ⎕TF B creates the corresponding object in the current workspace and Z is
the name of the object created (or '' if an error occurred).<br><h5><a id=CH_3.4.14.35></a>3.4.14.35 Z ← ⎕XML B : XML parser</h5>⎕XML provides a set of functions for parsing XML documents and to extract the
data contained in them. See <b>info apl</b> for details.<h5><a id=CH_3.4.14.36></a>3.4.14.36 Z ← ⎕TRACE B : TRACE vector</h5>⎕TRACE is similar to ⎕STOP above. The difference is that ⎕STOP stops the
execution when it hits a breakpoint while ⎕TRACE merely generates a printout
when it hits a breakpoint.<h5><a id=CH_3.4.14.37></a>3.4.14.37 Z ← ⎕UCS B : Universal Char Set</h5>⎕UCS converts APL characters to APL integers (with the codepoint of the
character), and vice versa. <b>B</b> can be a mix of characters and the direction
of the conversion is determined by the type of the item. Example:<pre class=input_T line=664>      ⎕UCS 'Hello ', 119 111 114 108 100</pre><pre class=output line=731>72 101 108 108 111 32 world
</pre><h3><a id=CH_3.5></a>3.5 Variables</h3>Like most computer languages, APL has variables. Unlike compiled computer
languages, variables in APL need not be declared beforehand. Instead,
variables are simply created by assigning a value to a name:<pre class=input_T line=664>      VAR ← 1 2 3</pre><pre class=output line=719>
</pre>If the name is in use for something other than a variable (for instance, a
defined function), then a VALUE ERROR will be raised. After a value has been
assigned to a name (and, as a side effect of that assignment, a variable with
that name has been created) referring to the name returns the most recent
value that was assigned to the variable:<pre class=input_T line=664>      VAR</pre><pre class=output1 line=732>1 2 3
</pre><pre class=input_ line=665>      VAR ← 1 2 3 4   ⍝ assignment to name VAR</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      VAR             ⍝ reference of name VAR</pre><pre class=output line=731>1 2 3 4
</pre>In the above examples a fundamental APL rule should be explained. Normally
a value being computed, for example a constant or the result of a function,
is displayed on the screen. If, however, the value is assigned to a variable,
then it becomes a <b>committed value</b> which is not displayed. The value is
not consumed by the assignment, so that it can be assigned to several variables
in one go:<pre class=input_T line=664>      V1 ← V2 ← 1 2 3</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V1</pre><pre class=output1 line=732>1 2 3
</pre><pre class=input_ line=665>      V2</pre><pre class=output line=731>1 2 3
</pre>The lifetime of a variable (though not the lifetime of their value which can
change over time) is normally infinite; such variables are called
<b>global variables</b>. There exist also <b>local variables</b> whose lifetime
begins when a defined function is called and ends when that function call
returns a result. This will be explained together with user defined functions).
The lifetime of a variable can be explicitly terminated by either the
command <b>)ERASE</b> or the APL function <b>⎕EX</b> (expunge):<pre class=input_T line=664>      V1</pre><pre class=output1 line=732>1 2 3
</pre><pre class=input_ line=665>      )ERASE V1</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V1</pre><pre class=errput1 line=743>VALUE ERROR
      V1
      ^
</pre><pre class=input_ line=665>      V2</pre><pre class=output1 line=732>1 2 3
</pre><pre class=input_ line=665>      ⎕EX 'V2'</pre><pre class=output1 line=732>1
</pre><pre class=input_ line=665>      V2</pre><pre class=errput line=742>VALUE ERROR
      V2
      ^
</pre>The result 1 of ⎕EX indicates successful erasure of the variable. Note
that the argument of ⎕EX is not the variable V2 but a character vector
'V2' containing the name of the variable.<h4><a id=CH_3.5.1></a>3.5.1 The Variables ⎕ and ⍞</h4>There are two important system variables, ⎕ (quad) and ⍞ (quote quad),
that are used because of their side effects. They are probably the most
frequently used system variables in APL programs.<h5><a id=CH_3.5.1.1></a>3.5.1.1 Input and Output with ⍞</h5>When a value is assigned to ⍞ then the value is displayed on the screen:<pre class=input_T line=664>      ⍞ ← 1 + 2   ⍝ compute 1 + 2 and display the result</pre><pre class=output line=731>3</pre>In the example above the <b>⍞ ←</b> is redundant, because the result 3
is not a committed value and would therefore have been displayed anyway.
However, <b>⍞ ←</b> is most useful to display committed values and temporary
values inside APL expressions, often for debugging purposes.<br><br>When ⍞ is referenced, then a line of input is read from the keyboard (actually
from stdin which is normally the keyboard) and the characters read,
excluding the end of line character. The result of referencing ⍞ is always
a character vector (the user input is quoted by ⍞, which may explain
its name quote quad).<pre class=input_T line=868>      INPUT ← ⍞   ⍝ quote-quad input</pre><pre class=input_ line=868>what we type</pre><pre class=output1 line=908></pre><pre class=input_ line=868>      INPUT</pre><pre class=output line=908>what we type</pre>An important special case arises when the assignment of a value to ⍞ (but
not ⎕) is immediately (i.e. without another input or output operation)
followed by a reference of ⍞. In that case the terminating end-of-line
character is suppressed and the input requested on the same line:<pre class=input_T line=868>      ⍞←"ENTER AMOUNT: " ◊ AMOUNT ← ⍞</pre><pre class=input_ line=868>ENTER AMOUNT: 42</pre><pre class=output1 line=908></pre><pre class=input_ line=868>      AMOUNT</pre><pre class=output line=908>              42</pre>This special case is often used in interactive APL programs to print a prompt
that tells the user what shall be entered. If this is not desired, then you
can use ⎕ instead of ⍞ in the first assignment:<pre class=input_T line=868>      ⎕←"ENTER AMOUNT: " ◊ AMOUNT ← ⍞</pre><pre class=input_ line=868>ENTER AMOUNT: </pre><pre class=input_ line=868>42</pre><pre class=output1 line=908></pre><pre class=input_ line=868>      AMOUNT</pre><pre class=output line=908>42</pre><h5><a id=CH_3.5.1.2></a>3.5.1.2 Input and Output with ⎕</h5>When a value is assigned to ⎕ then the value is displayed like for ⍞.
However, the terminating end of line character is always printed, so that
⎕ cannot display a prompt on the same line as the user input in the way
described for ⍞.<br><br>Reference to ⎕ differs from referencing ⍞ in two ways:<ol><li>⎕ displays its own prompt <b>⎕:</b> on a separate line, and<li>⎕ <i>evaluates</i> the input line as an APL expression, rather than quoting
it automatically like ⍞ does. The evaluation may produce an error if the
input entered is not a valid APL expression.</ol>The following examples may help explain the referencing of ⎕.<br><br><b>Example 1</b>: The user references ⎕ and assigns the result to a variable
named INPUT:<pre class=input_T line=868>      INPUT ← ⎕</pre><pre class=output line=908>⎕:</pre>After the ⎕: prompt, the user enters the (valid) APL expression <b>1 + 2</b>
which evaluates to <b>3</b>:<pre class=input_T line=868>      1 + 2
      INPUT</pre><pre class=output line=908>3</pre><br><br><b>Example 2</b>: Like before, the user references ⎕ and assigns the result to a
variable named INPUT:<pre class=input_T line=868>      INPUT ← ⎕</pre><pre class=output line=908>⎕:</pre>After the ⎕: prompt, the user enters the (valid, since quoted) APL string
<b>'Hello'</b> which evaluates to the character vector <b>Hello</b>:<pre class=input_T line=868>      'Hello'
      INPUT</pre><pre class=output line=908>Hello</pre><br><br><b>Example 3</b>: Like before, the user references ⎕ and assigns the result to
a variable named INPUT:<pre class=input_T line=868>      INPUT ← ⎕</pre><pre class=output line=908>⎕:</pre>After the ⎕: prompt, the user enters the (invalid, since not quoted) <b>Hello</b>.
<b>Hello</b> is now an APL name as opposed to an APL string as in example 2.
If a variable or niladic function with name <b>Hello</b> were defined, then its
value would be assigned to a variable named INPUT. In our example, however,
this is not the case and therefore a <b>VALUE ERROR</b> is raised:<pre class=input_T line=868>      Hello</pre><pre class=errput>VALUE ERROR
      Hello
      ^</pre><h5><a id=CH_3.5.1.3></a>3.5.1.3 ⎕ Input in Application Programs</h5>Input by means of ⎕ can be very powerful while writing and debugging APL
programs. It should be avoided, however, in finished application programs.
The reason is that ⎕ throws an error when the user enters something that
is not a valid APL expression. In contrast, input by means of ⍞ does not
throw errors and is therefore safer to use in application programs.<h3><a id=CH_3.6></a>3.6 Indexing</h3>Most programming languages provide indexing which either references or allows
updating a part of the value. Most often, however, indexing is restricted
to a single item. In APL, indexing is much more powerful and can even be
used to create larger APL values than the indexed value.
An <b>index expression</b>, or <b>index</b>, is a sequence of one or more
non-negative simple integers. The sequence is enclosed in brackets and the
components of the sequence are separated by semicolons (unless there is only
one component):<pre class=input_T line=868>     [1;2 3]</pre><pre class=output line=908></pre>The example above shows an index with 2 components 1 and 2 3. An index cannot
be used on its own, but is always bound to the value on its left. The value
left of an index is then said to be indexed by the index expression. The
semantics of indexing a value is that a subset of the ravel of the value
is being selected. This subset is then either referenced (copied) or
changed (assigned) depending on whether the indexed value appears on the
left of an assignment arrow ← or not. We call a value that is being assigned
an <b>lvalue</b> (for left value).
The index is most strongly bound to the value on its left, which causes
indexing of the value to be performed as soon as the value is available.
If the value is an lvalue (only named lvalues can be assigned) then the
lvalue is updated with some other value; otherwise the value is referenced.
Often the item left of the index is a variable and then it looks as if parts
the variable are updated or referenced:<pre class=input_T line=664>      V←1 2 3 4   ⍝ create a variable</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V[2 3]       ⍝ indexed reference</pre><pre class=output1 line=732>2 3
</pre><pre class=input_ line=665>      V[2 3]←'x'   ⍝ indexed assignment</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V            ⍝ show result of indexed assignment</pre><pre class=output line=731>1 xx 4
</pre>What happens behind the scene, however, is that the variable V in the above
examples is resolved into a value (indexed reference) or into an lvalue
(indexed assignment). The value or lvalue is then being indexed.
For indexing to be successful, the index must satisfy certain conditions:<ul><li>The number of components in the index (i.e. the number of semicolons + 1)
must be equal to the rank of the index<li>The i<sup>th</sup> component in the index must be an integer between 1 and the
i<sup>th</sup> component of the shape of the value that is being indexed.</ul>As a consequence of the first condition, scalars cannot be indexed
(an index without semicolons would require a rank of 1 for the indexed value).
The second condition ensures that the corresponding index components do not
exceed the corresponding shape components. As a C programmer or mathematician
you will find it more natural if the range of an index starts at 0 rather than
1. In APL this can be achieved by setting the system variable ⎕IO (index
origin) to 0:<pre class=input_T line=664>      ⎕IO←0</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      (1 2 3 4)[2]</pre><pre class=output1 line=732>3
</pre><pre class=input_ line=665>      ⎕IO←1</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      (1 2 3 4)[2]</pre><pre class=output line=731>2
</pre>Use of ⎕IO←0 should be minimized, however, because most APL programmers assume
the default value of 1 for ⎕IO and the readability of your code may suffer.
An indexed assignment has the side effect of changing parts of the variable,
but the result of it is the value that is assigned, i.e. the right side
of the assignment. The result is not displayed. In that respect, indexed
assignment behaves like non-indexed assignment.<pre class=input_T line=664>      V←1 2 3 4</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V[3 3 3⍴2]←'X'</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V</pre><pre class=output line=731>1 X 3 4
</pre>The example above does not make much sense because the same index 2 is
assigned 27 times. We used it to show the difference between indexed
reference below.
An indexed reference of a variable or value has a result whose shape is
the concatenated shape of the index. This can be used to create values that
are bigger than the indexed value:<pre class=input_T line=664>      (1 2 3 4)[3 3 3⍴2]</pre><pre class=output line=731>2 2 2
2 2 2
2 2 2

2 2 2
2 2 2
2 2 2

2 2 2
2 2 2
2 2 2
</pre>Indexing is one of the essential operations of APL programming and fully
understanding it is key to understanding APL. Therefore we summarize the
rules governing indexed assignment and indexed reference:<ul><li>Common Requirements on Z ← A[X<sub>1</sub>;...;X<sub>N</sub>] and
A[X<sub>1</sub>;...;X<sub>N</sub>] ← B<ul><li>A has rank N > 0 (and there are N-1 ≥ 0 semicolons inside the brackets).<li>Each X<sub>i</sub> is a non-nested integer value of arbitrary shape.<li>For every integer I in the ravel of X<sub>i</sub>: ⎕IO ≤ I &lt; ⎕IO + (⍴A)[i]).</ul><li>Indexed Assignment A[X<sub>1</sub>;...;X<sub>N</sub>] ← B<ul><li>A must be a named value, i.e. an APL variable.<li>The result of an indexed assignment is B; as a side effect, selected
items in the ravel of A are updated with corresponding items in the
ravel of B.<li>The result is a committed value (and is therefore not displayed).<li>If B is a scalar then it is scalar extended according to
X<sub>1</sub>, ..., X<sub>N</sub>.<li>Repeated values in some X<sub>i</sub> are valid, but the assignment is
implementation dependent (unless the corresponding items in B are
identical).<li>The shape of B can have trivial dimensions (dimensions of length 1). Such
dimensions are ignored. The length of any non-trivial dimension (⍴B)[i]
must match the number of elements ⍴,X<sub>i</sub> in the corresponding index
item X<sub>i</sub>.</ul><li>Indexed Reference Z ← A[X<sub>1</sub>;...;X<sub>N</sub>]<ul><li>The rank of the result, i.e. ⍴⍴Z, is the sum of the ranks of items
in the index list: ⍴⍴Z ↔ (⍴⍴Z<sub>1</sub>) + ... + (⍴⍴Z<sub>N</sub>)<li>The shape of the result is the catenation of items in the index
list: ⍴Z ↔ (⍴Z<sub>1</sub>), ..., (⍴X<sub>N</sub>)</ul></ul>A special case of an index item is the "elided index". If no value is given
between two brackets or semicolons, then this means that the entire dimension
(and not, as you might assume, nothing) is selected by the index item:<pre class=input_T line=664>      A←3 4 ⍴ 1 2 3 4 5 6 7 8 9 10 11 12</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      A</pre><pre class=output1 line=732>1  2  3  4
5  6  7  8
9 10 11 12
</pre><pre class=input_ line=665>      A[2;]   ⍝ elided index for last dimension, i.e. an entire "row"</pre><pre class=output1 line=732>5 6 7 8
</pre><pre class=input_ line=665>      A[;2]   ⍝ elided index for first dimension, i.e. an entire "column"</pre><pre class=output line=731>2 6 10
</pre>A final example shows the effect of multiple items in different dimensions:<pre class=input_T line=664>      A←6 20⍴'∘'</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      A</pre><pre class=output1 line=732>∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘∘
</pre><pre class=input_ line=665>      A[;2 3 9 14]←'║'   ⍝ set columns 2, 3, 9, and 14 to ║</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      A</pre><pre class=output1 line=732>∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
</pre><pre class=input_ line=665>      A[1 3 6;]←'═'   ⍝ set rows 1, 3, and 6</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      A</pre><pre class=output1 line=732>════════════════════
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
════════════════════
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
════════════════════
</pre><pre class=input_ line=665>      A[1 3 6;2 3 9 14]←'╬'   ⍝ set rows 1, 3, and 6 in columns 2, 3, 9, and 14</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      A</pre><pre class=output line=731>═╬╬═════╬════╬══════
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
═╬╬═════╬════╬══════
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
∘║║∘∘∘∘∘║∘∘∘∘║∘∘∘∘∘∘
═╬╬═════╬════╬══════
</pre>A disadvantage of APL bracket indexing is that while the shapes of the index
items can be freely chosen, the number of semicolons (and therefore the rank
of A) is fixed. That makes it impossible to write functions that cope with
arbitrary ranks of A.
For that reason, a dyadic function X⌷A (called index) is provided where
X plays the role of X<sub>1</sub>;...;X<sub>N</sub> in bracket index. X is a
(typically nested) vector of length N and both reference (Z←X⌷A) and
assignment (X⌷A)←B are possible. Unlike bracket index, scalars can be
indexed with the index function (X then has length 0), but elided indices
are not supported by the index function.<h3><a id=CH_3.7></a>3.7 Execution of APL Statements</h3>APL statements are either entered in immediate execution mode, or else
as the body lines of user defined functions.
An APL statement starts out as a sequence of characters other than the
statement separator ◊ (which, as the name suggests, separates different
statements on the same line) and the end of line character (linefeed).
The examples provided above were APL statements.
An example of a line with 3 statements (and no output) is this:<pre class=input_T line=664>      A←1 ◊ B←2 ◊ C←3</pre><pre class=output line=719>
</pre>The first thing the APL interpreter does when a statement is entered
is to convert the characters of the statement into an internal format
called tokens. The translation of a sequence of characters into a sequence
of tokens, commonly called <b>lexical analysis</b> or <b>tokenization</b>,
can lead to errors when characters are encountered that do not have
meaning in APL:<pre class=input_T line=664>      ∫ f(x) dx</pre><pre class=errput1 line=743>Unknown APL character: ∫ (U+222B)
Non-APL character+
</pre><pre class=output line=908></pre>The rules for tokenizing the input characters are relatively simple:<ul><li>APL literals are converted to a token that contains the APL value
represented by the literal (as discussed in previous chapters)<li>APL names are converted to a token that contains the name
(as discussed in previous chapters)<li>All other characters are converted to a token representing that character</ul>Tokenization is done because operation at the character level is relatively
inefficient, while the internal token format can be parsed more efficiently.
In compiled languages tokenization and parsing are both performed by the
compiler and the efficiency of the internal representation is not relevant
to the efficiency of the executable program. APL is interpreted, however,
so part of the parsing is performed at runtime and the purpose of tokenization
is to perform as much analysis of a statement as possible when the statement
is entered rather than later (and possibly repeatedly) when the statement
is executed.
As an example, the statement:<pre class=input_T line=664>      VARIABLE←1 2 'Hello' (2 'world')</pre><pre class=output line=719>
</pre>is converted into 3 tokens:<br><br><label class=token>VARIABLE</label><label class=token>←</label><label class=token>1 2 'Hello' (2 'world')</label><br><br>This is possible because the somewhat complicated looking value
<b>1 2 'Hello' (2 'world')</b> is entirely comprized of APL literals
which, unless preempted by a higher token binding precedence (see that
discussion below), can be collapsed into a single (here nested) value
at tokenization time. On the other hand, if there are non-literals
(such as functions or names) between the APL literals, then the literals
left or right of the non-literals cannot be combined and therefore
show up in different tokens:<pre class=input_T line=664>      VARIABLE←1 2 ⍴ 'Hello' (2 'world')</pre><pre class=output line=719>
</pre><br><label class=token>VARIABLE</label><label class=token>←</label><label class=token>1 2</label><label class=token>⍴</label><label class=token>'Hello' (2 'world')</label><br><br>In immediate execution mode, the token sequence created by the tokenization
of the input line is immediately executed, and there appears to be no
difference between tokenization time and execution time. With user defined
functions, however, it pays off to separate lexical analysis from parsing at
execution time. The token sequence for the statement is then stored until it
is executed.
Conceptually, the first step when a statement is executed is to group (also
called "bind") certain tokens to other tokens. APL has no operator precedence
like other languages (the large number of built-in functions and operators
in APL would have made that essentially unmanageable). However, the binding of
tokens plays a similar role. Unfortunately the ISO standard fails to mention
the rules for token binding, but we can refer to the descriptions of commercial
APL vendors. According to those descriptions the binding of tokens has the
following precedence (from strongest binding to weakest binding):<ol><li>bracket index to the token on its left<li>assignment arrow to the token on its left<li>dyadic operator to its right operand (the function on its right)<li>items in vector notation<li>operator to its left operand (the function on its left)<li>function to its left argument (the value on its left)<li>function to its right argument (the value on its right)<li>assignment arrow to the token on its right</ol>When we refer to, for example, a "token on its left", then this means when
the token becomes available. In the following example:<pre class=input_T line=664>      (2 × 1 2 3 4)[2]</pre><pre class=output line=731>4
</pre>the bracket index [2] has the strongest binding. Before that binding can
take place, however, the expression in parentheses, (2 × 1 2 3 4), must
have been evaluated (yielding 2 4 6 8). The vector 2 4 6 8 is then indexed by
bracket index [2] to give the final result 4.<br><br>You may also wonder why operators bind to their operand but not to their
arguments. The reason is that:<ul><li>when a dyadic operator binds to its right operand, then the bound dyadic
operator has become a monadic operator.<li>when a monadic operator (or a bound dyadic operator) binds to its left
operand, then the bound monadic operator has become a function.<li>the bound monadic operator, then binds to its left and right arguments like
every other dyadic or monadic function.</ul>Note also that the actual number of binding strengths is smaller than the list
above might suggest. This is because some bindings are not in conflict with
each other. For example, vector notation binds two or more values to each
other, while the next lower binding strength binds an operator to a function.
These two bindings could have been given the same binding strength.<br><br>Some bindings merely define the order in which things are evaluated while
others produce an intermediate result. For example, the binding of a dyadic
function to its left argument forces a left argument in parentheses to be
evaluated first and then the result to be passed to the dyadic function.
On the other hand, the binding of a bracket index to the value or lvalue
on its left forces immediate computation of the bracket index as described
above.<br><br>After binding the token, the evaluation of APL statements is performed
according to the "golden rule" of APL:<br><br><b>The rightmost function whose argument(s) are available is evaluated
first.<br>The function and its argument(s) are then replaced by the result
returned by the function, which causes the arguments of other functions
to become available.</b><br><br>In short this means that APL statements are evaluated from right to left.
Another consequence is that parentheses around the right argument of a
function have no effect, while parentheses around the left argument make
a difference:<pre class=input_T line=664>      (1 + 2) × (3 + 4)   ⍝ 3 × 7</pre><pre class=output1 line=732>21
</pre><pre class=input_ line=665>      (1 + 2) × 3 + 4     ⍝ 3 × 7</pre><pre class=output1 line=732>21
</pre><pre class=input_ line=665>      1 + 2 × (3 + 4)     ⍝ 1 + (2 × 7)</pre><pre class=output1 line=732>15
</pre><pre class=input_ line=665>      1 + 2 × 3 + 4       ⍝ 1 + (2 × 7)</pre><pre class=output line=731>15
</pre><h3><a id=CH_3.8></a>3.8 Defined Functions</h3>Programming in APL is primarily concerned with the creation and testing of
user defined functions. The immediate execution mode used so far is helpful
to try things out, but not for larger applications.<br><br>For the sake of explanation we define a user defined function to be a
non-empty sequence of <b>function lines</b> numbered 0, 1, .... The first
line is called function header and determines the following properties of
the function:<ul><li>if the function returns a value or not<li>the valence (number of value arguments): niladic, monadic, or dyadic<li>the name of the function or operator<li>the number of function arguments: none (normal function),
1 (monadic operator), or 2 (dyadic operator)<li>the optional axis of the function or monadic operator<li>the names of local variables of the function</ul><h4><a id=CH_3.8.1></a>3.8.1 Function Header</h4>The header line of a user defined function consists of several APL names
interleaved with some of the characters ←, (, ), [, ], and ;.
The names can be freely chosen by the user; we will use the names
Z, A, LO, F, X, B, RO, C, and D in our examples with the following meaning:<ul><li>Z: the name of the result<li>A: the left value argument<li>LO: the left function argument of an operator<li>RO: the right function argument of a dyadic operator<li>F: the name of the function<li>X: the axis argument<li>B: the right value argument<li>C: the first local variable<li>D: the second local variable...</ul>The syntax of the function header is then:<br><br>function-header ::= result-spec function-and-args local-variables<br>result-spec ::= empty | Z ←<br>function-and-args ::= function-spec | function-spec B | A function-spec B<br>function-spec ::= function | ( LO function ) | ( LO function RO )<br>function ::= F | F [ X ]<br>local-variables ::= empty | ; C local-variables<br><br>Additional requirements are that all names in the header must be different and
that no name (with the exception of names for local variable names) can be a
user defined name. The name of a local variable may be the name of system
variables, but must not be the name of a system function or primitive.<br>The possible combinations in the syntax above produces 2×3×3×2 = 36
different header variants. Of these 36 variants the following 7 combinations
are not allowed:<ul><li>niladic function with axis<li>monadic operator operator with no value arguments<li>monadic operator operator with axis and no value arguments<li>dyadic operator operator with no value arguments<li>dyadic operator operator with axis and no value arguments<li>dyadic operator operator with axis and one value argument<li>dyadic operator operator with axis and two value arguments</ul>The following sections describe the different fields of the function header.
Before that we briefly describe one way to create and display user defined
functions.<h5><a id=CH_3.8.1.1></a>3.8.1.1 Creating and displaying defined functions: ⎕FX and ⎕CR</h5>The monadic system function ⎕FX creates a new function. The single argument
of ⎕FX is either a character matrix (the first row of that matrix is the
function header) or a vector of nested character vectors (with the first
character vector the header of the function). The remaining rows of
the matrix or the remaining character vectors are the body lines of the
function being created. On success ⎕FX returns the name of the function
that it has created.
Monadic ⎕CR displays the header and body lines of a function. The single
argument of ⎕CR is the name of the function to be displayed. ⎕CR returns
a matrix with the function header and the function body.<pre class=input_T line=664>      )CLEAR</pre><pre class=output1 line=732>CLEAR WS
</pre><pre class=input_ line=636>      ∇FOO
      1 + 2
      ∇
</pre><pre class=input_ line=665>      ⎕CR 'FOO'</pre><pre class=output line=731>FOO
1 + 2
</pre><h5><a id=CH_3.8.1.2></a>3.8.1.2 Result Specification</h5>The example above has created a function FOO that had no result specification.
Such functions can be executed, but they do not return a result and attempts
to use their return fails:<pre class=input_T line=664>      )CLEAR</pre><pre class=output1 line=732>CLEAR WS
</pre><pre class=input_ line=636>      ∇FOO
      1 + 2
      ∇
</pre><pre class=input_ line=665>      FOO                 ⍝ call FOO (that is OK)</pre><pre class=output1 line=732>3
</pre><pre class=input_ line=665>      VAR←FOO             ⍝ try to use FOO's result (that is an error)</pre><pre class=output1 line=732>3
</pre><pre class=errput line=742>VALUE ERROR+
      VAR←FOO
      ^
</pre>The reason why some value (3) was displayed is not because FOO has returned
the result 3, but because the statement '1 + 2' was not assigned to a variable
and therefore printed.
For a function to return a result, two conditions must be met:<ol><li>the header must contain a result specification such as <b>Z←</b>, and<li>the variable named in the result specification must be assigned during
the execution of the function</ol>The result specification is a user-defined name followed by the assignment
arrow ← :<pre class=input_T line=664>      )CLEAR</pre><pre class=output1 line=732>CLEAR WS
</pre><pre class=input_ line=665>      ⍝ define FOO returning result Z</pre><pre class=input_ line=636>      ∇Z←FOO
      Z←1 + 2
      ∇
</pre><pre class=input_ line=665>      FOO                         ⍝ call FOO</pre><pre class=output1 line=732>3
</pre><pre class=input_ line=665>      VAR←FOO                     ⍝ try to use FOO's result</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      VAR   ⍝ show result</pre><pre class=output line=731>3
</pre>The output of simply calling FOO is the same as before. However, the value
3 is now the result of FOO and not the result of the statement Z←1 + 2 inside
FOO. This is because the assignment Z←1 + 2 is now a committed value which
is not printed.
If the function header has a result specification, but the result variable is
not assigned, then<pre class=input_T line=664>      )CLEAR</pre><pre class=output1 line=732>CLEAR WS
</pre><pre class=input_ line=665>      ⍝ define FOO returning Z without assigning Z (which is more often than not an error)</pre><pre class=input_ line=636>      ∇Z←FOO
      1 + 2
      ∇
</pre><pre class=input_ line=665>      FOO  ⍝ call FOO</pre><pre class=output1 line=732>3
</pre><pre class=input_ line=665>      VAR←FOO  ⍝ call FOO (OK) and try to use FOO's result (ERROR)</pre><pre class=output1 line=732>3
</pre><pre class=errput line=742>VALUE ERROR+
      VAR←FOO
      ^
</pre>Forgetting, as above, to assign the result value inside a defined function
whose header indicates that the function returns a result is an error that
is sometimes hard to discover, in particular when the function contains
branches (so that some execution paths assign the result and some don't).
In that case the programmer may be mislead by the fact that the function
header indicates a result and incorrectly assumes that the result variable
is actually assigned before the function returns.<h5><a id=CH_3.8.1.3></a>3.8.1.3 Local Variables</h5>The function header can optionally contain a list of local variables. Every
local variable is appended to the function header with a semicolon in front
of it. For example:<pre class=input_T line=868>A FOO B;C;D</pre><pre class=output line=908></pre>is the header of a dyadic function (with arguments A and B) and local
variables C and D.
At this point we should reveal that every user defined name, and also the
APL system variables have an associated stack, The stack is created when
the name is first mentioned (or from the outset if the name refers to an
APL system variable).
When a user defined function is called, then the stack of the following
names is pushed:<ul><li>the function result<li>the function arguments<li>the local variables, and<li>labels (see below)</ul>After pushing a name, the name refers to nothing, which is usually changed
shortly after pushing it. The previous values of the name are now
inaccessible. Only the item on the top of a name's stack can be accessed.
The name on the top of the stack remains accessible until either another
(or the same) function with the same name in its local variables is called,
or else until the functions returns. If the function returns then the stacks
of all its local variable names are popped and the previous top of the stack
becomes accessible again.<h5><a id=CH_3.8.1.4></a>3.8.1.4 The Del Editor</h5>⎕FX is not the only way to create user defined functions. ⎕FX is good if
the function created is small and is often the only way to create new
functions programmatically. An alternative present in many APL interpreters
is the interactive 'Del' editor. The Del editor is started by entering
the APL character Nabla (<b>∇</b>) and the full header of the new function.
The Del editor has simple commands for displaying, inserting, editing, and
deleting function lines.
The Del editor has a prompt which is the next line to be added or changed;
This line is displayed in square bracket. If the user wants to change a
different line than the line proposed by the Del editor then the desired
line is entered (again in square brackets). The following is an overview of
Del editor commands:<br><br><table cellspacing=0 cellpadding=0><tbody><tr><th>Command<th>Effect<tr><td class=tab>[N]<td class=tab>Continue editing with line N<tr><td class=tab>[⎕]<td class=tab>display all function lines<tr><td class=tab>[⎕N]<td class=tab>display the function lines 1 to N (inclusive)<tr><td class=tab>[N⎕]<td class=tab>display the function line N and those following<tr><td class=tab>[N⎕M]<td class=tab>display function lines N to M (inclusive)<tr><td class=tab>[∆N]<td class=tab>delete function lines N<tr><td class=tab>[N∆M]<td class=tab>delete function lines N to M<tr><td class=tab>[→]<td class=tab>discard changes<tr><td class=tab>∇<td class=tab>close the Del editor</table><br><br>Entering a non-existing fractional number, like in [3.5] creates a new line
between the closest existing lines (between lines 3 and 4 if there are no
other fractional line numbers between 3 and 4). When the Del editor is
closed then all lines will be renumbered, starting with header line 0.<br>These days you will probably use your own editor like <b>Vim</b> or <b>emacs</b>
to edit APL functions and then cut-and-paste them into the window in which APL
runs, or start APL with a text file containing function definitions. However,
at the time when the Del editor was developed, computer mice were not yet
invented and terminals were too limited in functionality to support
cut-and-paste. Most commands of the Del editor are irrelevant today, but the
Del editor is still the method of choice when defining functions in
(non-interactive) APL scripts to create new APL functions.<br>For example, say you have a normal (UTF8 encoded) text file containing
the following:<pre class=input_T line=868>∇ Z←FOO
  1 + 2
∇</pre><pre class=output line=908></pre><br>That defines the same function as;<pre class=input_T line=868> ⎕FX 'Z←FOO' '1 + 2'
</pre><pre class=output line=908></pre><br>but is more readable, in particular when functions become longer. We will
use this format for displaying functions. The above format is also suitable
for displaying APL code snippets in emails or on web pages. The reader can
simply cut-and-paste them into his interpreter (provided of course, that
the interpreter uses UTF8 encoded Unicode and not special APL fonts).<h5><a id=CH_3.8.1.5></a>3.8.1.5 Function Body</h5>The remaining lines of a function are called the <b>function body</b>.
The function body consists of 0 or more <b>function lines</b>. Every
function line consists of 0 or more APL statements like those already
discussed above.
A function line can have an optional <b>label</b>. A label is another kind
of local variable that is automatically created, cannot be changed, and
has an integer value that is equal to the number of the line on which it
was written. For example:<pre class=input_T line=868>∇A FOO1 B;C;D
L1: 'line 1'
L2: 'line 2'
 X←L2
∇</pre><pre class=output line=908></pre>The hypothetical function FOO1 above has two arguments A and B, explicit
local variables C and D, and labels L1 and L2. The syntax for a label is a
name followed by a colon. The variable X would get the value 2 because
label L2 is on line 2. labels are read-only; attempting to change their
value yields a SYNTAX ERROR. Labels will be discussed together with branching
in functions below.<h4><a id=CH_3.8.2></a>3.8.2 How Functions and Operators are Evaluated</h4>The execution (or evaluation) of a function starts when the function name
is detected in a statement and all its arguments (as defined by the header
of the function) are present. Lets assume we define FOO like this:<pre class=input_T line=664>      )CLEAR</pre><pre class=output1 line=732>CLEAR WS
</pre><pre class=input_ line=665>      ⍝ define dyadic FOO with result Z and arguments A and B</pre><pre class=input_ line=636>      ∇Z←A FOO B;C;D
      L1: 'line 1'
      L2: 'line 2'
      X←L2
      Z←42
      ∇
</pre><pre class=input_ line=665>      ⎕CR 'FOO'   ⍝ check FOO</pre><pre class=output1 line=732>Z←A FOO B;C;D
L1: 'line 1'
L2: 'line 2'
X←L2
Z←42
</pre><pre class=output line=908></pre>Then we enter the following in immediate execution mode:<pre class=input_T line=664>      (3 + 4) FOO 5</pre><pre class=output line=731>line 1
line 2
42
</pre>The APL interpreter will see FOO, but it will notice that the left argument
of FOO, i.e. (3 + 4,) is not yet available because the result of (3 + 4) has
not yet been computed. The interpreter will therefore compute (3 + 4) first
and replace it by 7. We have now:<pre class=input_T line=868> 7 FOO 5</pre><pre class=output line=908></pre>The interpreter can now evaluate 7 FOO 5 (or some other function in the
general case) as follows:<ol><li>first the stacks of all names are pushed. In our example, the names
being pushed are Z, A, B, C, D, L1, and L2 (but not FOO!)<li>next the actual arguments of the function (7 and 5) are assigned to
the formal parameters (A and B) of the function. That is, A←7 and B←5.<li>the labels are assigned, i.e. L1←1 and L2←2.<li>(at this point, the function result Z and the local variables C and D
are undefined, while the function arguments A and B and the labels
have values)<li>the statements in the function body are executed, starting with the
first statement in the first line.<li>the function result Z, which may or may not be defined is stored in
a temporary location.<li>all stacks of all names that were pushed above are popped. They now have
the value they had when FOO was called.<li>the function and its arguments are replaced by the function result in
the temporary location.</ol>In our example, the following output is produced:<pre class=input_T line=664>      (3 + 4) FOO 5</pre><pre class=output line=731>line 1
line 2
42
</pre>The first two output lines ("line 1" and "line 2") are output from lines
1 and 2 of FOO, while the last line is the return value from FOO which
is displayed <b>after</b> FOO has returned.<h4><a id=CH_3.8.3></a>3.8.3 Branching</h4>The examples of user defined functions given so far were "linear" by which
we mean that the statements in the body of the function were executed one
after the other until the end of the function was reached.<br>In addition to that, APL provides a means to change the order of the
normal program flow from the beginning of a function to its end: a
computed branch.<br><br>APL has been criticized for having only one way of changing the order of
the program flow instead of many (like if/else, for, while, and case in C/C++).
However the computed branch in APL is so powerful that it can easily emulate
the multiple flow control statements in other languages. And the fact that APL
works on larger data structures than scalars makes the low-level loops found
in other languages obsolete.<br><br>A <b>computed branch</b> is a statement that consists of a branch arrow (→) and
a numeric APL value. A slightly different statement, called <b>Escape</b>
consists of the same branch arrow, but without the value. For example:<ul><li>→L ⍝ computed branch (to label L)<li>→ ⍝ escape</ul><h5><a id=CH_3.8.3.1></a>3.8.3.1 Labels</h5>The numeric argument of a computed branch is a line number. So →1 is a
branch to line 1 of some user defined function. However, absolute line
numbers should never be used for branching. The reason is that APL renumbers
the lines of a user defined function when new lines are added between
existing lines. The line numbers in branches are not renumbered when
renumbering lines and as a consequence the absolute line numbers in branches
become invalid. This problem can easily be solved by using labels.<br>A label is an APL name followed by : (colon) at the beginning of a line.
The label is an automatically created local variable whose value is
the line number on which it was written and the variable is read-only
(i.e. one cannot assign a new value to it). Unlike absolute line numbers,
labels move with their line when other lines are inserted before them and
a subsequent renumbering of lines does them no harm.<br>Example:<pre class=input_T line=868></pre><pre class=output line=908>∇FOO
    'line 1' ◊ →3    ⍝ Bad: absolute branch to line 3
    'line 2' ◊ →L3   ⍝ Good: branch to line 3 with label L3
L3: 'line 3' ◊
∇</pre>If another line is inserted before the first line, then FOO becomes:<pre class=input_T line=868></pre><pre class=output line=908>∇FOO
    'new line before line 1'
    'line 1' ◊ →3    ⍝ Bad: absolute branch to line 3
    'line 2' ◊ →L3   ⍝ Good: branch to line 3 with label L3
L3: 'line 3' ◊
∇</pre>The previous line 3 with label L3 is now line 4. The branch to the absolute
line number 3, i.e. →3, now branches to the line before the line with label
L3 (which is now most likely wrong), while the branch to label L3 remains
correct.<h5><a id=CH_3.8.3.2></a>3.8.3.2 Computed Branch (inside a function)</h5>Inside a function a computed branch →EXPR where EXPR is some APL expression
is executed as follows.<ul><li>first the expression EXPR is evaluated. If the evaluation of EXPR fails
then this is an error and execution of the function stops as described
later on.<li>Let X be the result of evaluating EXPR. Then:<ul><li>if X is empty, then execution continues with the next statement after
the branch. This can be used to emulate an if statement in C++<li>if X is not empty, then it is expected to be a vector whose first
element is an integer L.<ul><li>if L is a valid line number, (a number between 1 and
the number of lines in the function (inclusive)) then
then a branch to that line is performed. That is, execution
continues at the first statement on the new line.<li>Otherwise, i.e. L is ≤ 0 or larger than the number of lines
in the function, then execution of the function is ended.</ul></ul></ul>In the following we explain some examples of frequently used branch patterns
and their "equivalents" in C/C++<pre class=input_T line=868></pre><pre class=output line=908>                 ⍝ meaning                C/C++

 →0              ⍝ leave the function     return;
 →(COND)⍴0       ⍝ dito if COND           if (COND) return;
 →(COND)↓0       ⍝ dito if not COND       if (!COND) return;

 →LAB            ⍝ goto line LAB          goto LAB;
 →(COND)⍴LAB     ⍝ dito if COND           if (COND)   goto LAB;
 →(COND)↓LAB     ⍝ dito if not COND       if (!COND)  goto LAB;

 →⎕LC            ⍝ repeat current line
 →(COND)⍴⎕LC     ⍝ dito if COND           do { current line } while (COND)

 →⎕LC+1          ⍝ goto next line
 →(COND)⍴⎕LC+1   ⍝ dito if COND           if (COND)     { rest-of-line }

 →⎕LC-1          ⍝ goto previous line
 →(COND)⍴⎕LC-1   ⍝ dito if COND

 →(X=V1,V2 ...)/L1, L2, ...)   ⍝          switch(X) { case V1: goto L1; ... }
</pre>In the examples above COND is usually a Boolean expression such as A ≤ B.<br><br>Since all APL comparison operators have negated forms (=/≠, ≤/>, &lt;/≥,
etc.) the (COND)↓ patterns above are far less frequent then the (COND)⍴
patterns. Note also that the (COND)↓ only works for single line numbers
(like 0 or LAB above) but NOT for possibly longer vectors like ⎕LC.<br><br>The (COND)⍴ pattern also works for non-Boolean integer expressions (like
if (COND) with non-integer COND in C/C++). It should not be used,
however, if the integer COND is large because then the computation of
⍴ takes a long time and all but the first element of its result is discarded.
To avoid that, use 0≠COND instead of COND if COND may be a large integer.<h5><a id=CH_3.8.3.3></a>3.8.3.3 Computed Branch (outside a function)</h5>If a computed branch statement is executed outside a function (for example
after an error in a function interrupts the execution of the function and
returns to immediate execution mode) then the branch is executed as if it
were executed inside the interrupted function. An error is thrown if no
interrupted function exists.<br><br>This can be used to jump back (i.e. continue) the execution of a function
that was interrupted (typically after removing the cause of the error).<h5><a id=CH_3.8.3.4></a>3.8.3.4 Escape (Unwind)</h5>A single → terminates the execution of the current defined function and
removes it from the )SI stack. After that the caller of the current defined
function becomes the current defined function.<h2><a id=CH_4></a>4 Commands</h2>Every APL interpreter provides a number of commands that can be entered in
immediate execution mode. The ISO standard defines a small number of standard
commands, and every interpreter adds its own commands for various purposes.
Commands do not follow the syntax of the APL language, but are more similar to
the input of a shell (a command, followed by mandatory or optional arguments).
A command starts with the character ) (or ] for some interpreters) followed by
a name.<h3><a id=CH_4.1></a>4.1 Standard Commands</h3><h4><a id=CH_4.1.1></a>4.1.1 )CLEAR</h4>Syntax: <b>)CLEAR</b><br><br>Re-initializes the current workspace. All user-defined functions and
variables are deleted and all system variables are reset to their default
values. The workspace name is set to <b>CLEAR WS</b>.<h4><a id=CH_4.1.2></a>4.1.2 )COPY</h4>Syntax: <b>)COPY [lib] wsname [object ...]</b><br><br><b>lib</b> is an optional library reference number from 0 to 9. If <b>lib</b>
is omitted then it is taken to be 0. The library reference number selects
one of 10 directories (which can be configured elsewhere, see command
<b>)LIBS</b> below) that contain workspace files.<br><br><b>wsname</b> then selects a workspace file in the directory selected by <b>lib</b>.<br><br>Normally the name of the workspace file is either <b>wsname.apl</b> or else
<b>wsname.xml</b>. However, if <b>lib</b> is omitted, then the workspace file
need not be contained in the directory corresponding to library reference 0,
but <b>wsname</b> may instead be an absolute path to the workspace file that
shall be copied. This can be useful if the workspace file resides in a
non-standard (according to <b>)LIBS</b>) directory, or if both <b>wsname.apl</b>
and <b>wsname.xml</b> exist in the same directory.<br><br><ul><li>If <b>object</b>(s) is omitted, then <b>all</b> user-defined variables,
defined functions, and defined operators in the selected workspace
are copied into the current workspace.<li>Otherwise only those user-defined variables, defined functions, and defined
operators whose names starts with one of the names in <b>object ...</b> are
copied into the current workspace.</ul><h4><a id=CH_4.1.3></a>4.1.3 )COPY_ONCE</h4><br><br>Like )COPY, but the workspace file is copied at most once. Subsequent
)COPY_ONCE of the same workspace file will be ignored.<h4><a id=CH_4.1.4></a>4.1.4 )DROP</h4>Syntax: <b>)DROP [lib] wsname</b><br><br><b>lib</b> is an optional library reference number as for command <b>)COPY</b>
above.<br><br><b>wsname</b> selects a workspace in the directory selected by <b>lib</b>. If
<b>lib</b> is omitted then an absolute path to the workspace file is accepted
as <b>wsname</b>.<br><br>Delete the workspace (<b>CAUTION:</b> without any warning).<h4><a id=CH_4.1.5></a>4.1.5 )ERASE</h4>Syntax: <b>)ERASE symbol ...</b><br><br>The variable, defined function, or defined operator with name <b>symbol</b>
is deleted in the current workspace.<h4><a id=CH_4.1.6></a>4.1.6 )FNS</h4>Syntax: <b>)FNS [from-to]</b><br><br>Display the names of defined functions in the current workspace.<br><br>For workspaces with many defined functions, characters <b>from</b> and <b>to</b>
can be used as a filter that specifies an alphabetic range of names.<h4><a id=CH_4.1.7></a>4.1.7 )LIB</h4>Syntax: <b>)LIB [lib|path] [from-to] [sort]</b><br><br><b>lib</b> is an optional library reference number as for command <b>)COPY</b>
above. Alternatively, <b>path</b> may be the absolute path to a non-standard
directory that contains workspace files.<br><br><b>from-to</b> is an optional name filter like in <b>)FNS</b> above.<br><br><b>sort</b> is an optional sorting mode, either <b>-size</b> or else <b>-time</b>.<br><br>The workspaces in the selected directory are displayed.
For directories with many workspace files, characters <b>from</b> and
<b>to</b> can be used as a filter that specifies an alphabetic range of names.
If no sorting mode is specified then <b>)LIB</b> shows workspaces names
(see <b>)WSID</b> below), i.e. without their <b>,apl</b> or <b>.xml</b>
file name extension. Otherwise the file names are displayed with
their <b>.apl</b> or <b>.xml</b> extension.<h4><a id=CH_4.1.8></a>4.1.8 )LOAD</h4>Syntax: <b>)LOAD [lib] wsname</b><br><br><b>lib</b> is an optional library reference number as for command <b>)COPY</b>
above.<br><br><b>wsname</b> selects a workspace in the directory selected by <b>lib</b>. If
<b>lib</b> is omitted then an absolute path to the workspace file is accepted
as <b>wsname</b>. The current <b>)WSID</b> is updated accordingly.<br><br>The current workspace is discarded and the workspace stored in the
selected workspace file is made the current workspace.<h4><a id=CH_4.1.9></a>4.1.9 )NMS</h4>Syntax: <b>)NMS [from-to]</b><br><br>Display the names of variables, defined functions, and defined operators
in the current workspace.<br><br>For workspaces with many names, characters <b>from</b> and <b>to</b> can be
used as a filter that specifies an alphabetic range of names.<h4><a id=CH_4.1.10></a>4.1.10 )OPS</h4>Syntax: <b>)OPS [from-to]</b><br><br>Display the names of defined operators in the current workspace.<br><br>For workspaces with many defined operators, characters <b>from</b> and <b>to</b>
can be used as a filter that specifies an alphabetic range of names.<h4><a id=CH_4.1.11></a>4.1.11 )SAVE</h4>Syntax: <b>)SAVE</b><br><br>Save the current workspace in the file <b>wsname.xml</b> where <b>wsname</b>
is defined by the current workspace name (as per <b>)WSID</b>).<br><br>Syntax: <b>)SAVE [lib] wsname</b><br><br><b>lib</b> is an optional library reference number as for command <b>)COPY</b>
above.<br><br><b>wsname</b> selects a workspace in the directory selected by <b>lib</b>. If
<b>lib</b> is omitted then an absolute path to the workspace file is accepted
as <b>wsname</b> and this becomes the new workspace id.<br><br>Save the current workspace in the file <b>wsname.xml</b> in the directory
selected by <b>lib</b>.<h4><a id=CH_4.1.12></a>4.1.12 )SI</h4>Syntax: <b>)SI</b><br><br>Every workspace contains a so-called <b>State Indicator</b> similar to the
stack-trace of a C program when run in a debugger. Every time a defined
function is called a new entry for the defined function is added, and
the entry is deleted again when the defined function returns. Due to this
last-in-first-out nature the <b>State Indicator</b> is also called the
<b>)SI stack</b>.<br><br>When the interpreter returns to immediate execution as a result of an
error, then the command <b>)SI</b> can be used to display the (recursive)
set of defined functions that have been called but not yet finished, and
the line number of the current statement in each function.<br><br>The <b>)SI</b> command itself displays only the function name and its line
number. However there exist several variants of the <b>)SI</b> command that
provide additional information for debugging purposes. For example:<br><br><pre class=input_T line=664>      ⍝ clear the SI stack</pre><pre class=input_ line=665>      )SIC</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      ⍝ show the SI stack (which is always empty after )SIC)</pre><pre class=input_ line=665>      )SI</pre><pre class=output1 line=720></pre><pre class=input_ line=636>      ∇FOO;A;B;C
      1 + 2
      ÷0      ⍝ provoke a DOMAIN ERROR'
      ∇
</pre><pre class=input_ line=665>      FOO</pre><pre class=output1 line=732>3
</pre><pre class=errput1 line=743>DOMAIN ERROR
FOO[2]  ÷0
        ^
</pre><pre class=input_ line=665>      ⍝ show the SI stack again</pre><pre class=input_ line=665>      )SI</pre><pre class=output1 line=732>FOO[2]
⋆
</pre><pre class=output line=908></pre>In the output of command )SI: an immediate execution entry is displayed
as <b>*</b> while a defined function is displayed as the function name followed
by a line number of the function in brackets. In the example above:<ol><li>The first line is the )SI entry for the execution of <b>FOO</b>. The
execution was stopped in line 2 due to the DOMAIN ERROR, and<li>The last * is the )SI entry for the immediate execution context in which
command )SI was entered. Whenever APL detects an error, it stops execution and
created a new )SI entry with mode immediate execution in which the user can
then issue commands like )SI and/or change variables, and/or continue execution
at the point where the error was detected.</ol><h4><a id=CH_4.1.13></a>4.1.13 )SIC</h4>Syntax: <b>)SIC</b><br><br>Clear the <b>)SI stack</b> (remove all items and release its resources,
particularly localized variables).<h4><a id=CH_4.1.14></a>4.1.14 )SINL</h4>Syntax: <b>)SINL</b><br><br>)SI with Name List. Same as )SI, but the display of the )SI stack is augmented
with the local variables of the function called. In the )SI example:<br><br><pre class=input_T line=664>      )SINL</pre><pre class=output1 line=732>FOO[2]  A B C
⋆
</pre><pre class=output line=908></pre>The first line shows that function FOO was called and has localized the names
A, B, and C. The second line is an immediate execution context (which cannot
localize variables). )SINL is useful for determining the scope of a variable
(e.g. which defined function has last localized it).<h4><a id=CH_4.1.15></a>4.1.15 )SIS</h4>Syntax: <b>)SIS</b><br><br>)SI with Statement. Same as )SI, but the display of the )SI stack is augmented
with the current statement in the function called (and possibly the error
message if the statement had raised an error). In the )SI example:<pre class=input_T line=664>      )SIS</pre><pre class=output1 line=732>FOO[2]  ÷0
        ^
⋆  FOO
   ^
</pre><pre class=output line=908></pre>The first line shows the APL statement <b>÷0</b> in line 2 of FOO which caused
the DOMAIN ERROR. The second line shows the statemant <b>FOO</b> that called
FOO. The order in the display of the )SI stack is therefore from most recent
to least recent (or downwards from called function to calling function).<h4><a id=CH_4.1.16></a>4.1.16 )VARS</h4>Syntax: <b>)VARS [from-to]</b><br><br>Display the names of user-defined variables in the current workspace.<br><br>For workspaces with many user-defined variables, characters <b>from</b> and
<b>to</b> can be used as a filter that specifies an alphabetic range of names.<h4><a id=CH_4.1.17></a>4.1.17 )WSID</h4>Syntax: <b>)WSID</b><br><br>Display the name of the current workspace.<br><br>Syntax: <b>)WSID wsname</b><br><br>Set the name of the current workspace to <b>wsname</b>. The name of the
workspace is used, for example, when )DUMP or )SAVE is used and the
filename is ommitted.<h3><a id=CH_4.2></a>4.2 IBM APL2 Commands</h3>GNU APL also understands most of the IBM APL2 commands.<h4><a id=CH_4.2.1></a>4.2.1 )CHECK</h4>Syntax: <b>)CHECK</b><br><br>Perform an internal check of the internal data structures, primarily to
detect memory leaks.<h4><a id=CH_4.2.2></a>4.2.2 )CONTINUE</h4>Syntax: <b>)CONTINUE</b><br><br>Save the current workspace under the name <b>CONTINUE.xml</b> and exit. If APL is
started later on and a workspace named CONTINUE exists, then that workspaces
is <b>)LOAD</b>ed automatically. In other words, the APL session is continued
at the point where it was left with command <b>)CONTINUE</b>.<h4><a id=CH_4.2.3></a>4.2.3 )HELP</h4>Syntax: <b>)HELP</b><br><br>Display a list of all GNU APL commands, system variables, and system functions.<br><br>Syntax: <b>)HELP primitive</b><br><br>Display a brief help text for the APL primitive <b>primitive</b>.<h4><a id=CH_4.2.4></a>4.2.4 )HOST</h4>Syntax: <b>)HOST command ...</b><br><br>Execute command <b>command ...</b> in the operating system under which GNU APL
runs.<h4><a id=CH_4.2.5></a>4.2.5 )IN</h4>Syntax: <b>)IN filename [object ...]</b><br><br>Like <b>)LOAD filename [object ...]</b>, but for a workspace saved with
command <b>)OUT</b> (see below).<h4><a id=CH_4.2.6></a>4.2.6 )MORE</h4>Syntax: <b>)MORE</b><br><br>APL errors like <b>DOMAIN ERROR</b>, <b>INDEX ERROR</b> etc. are displayed
automatically if they occur. For some of these errors, the interpreter has
additional information which is, however, not displayed automatically.
Command <b>)MORE</b> may display this additional information. Example:<pre class=input_T line=664>      1 2 3 ⎕MAP 1 2 3</pre><pre class=errput1 line=743>LENGTH ERROR+
      1 2 3 ⎕MAP 1 2 3
      ^     ^
</pre><pre class=input_ line=665>      )MORE</pre><pre class=output1 line=732>Odd length of A in A ⎕MAP B
</pre><pre class=output line=908></pre>A + character at the end of the APL error indicates that some additional
information is present and can be displayed with <b>)MORE</b> but it
must be invoked before anything else is done.<h4><a id=CH_4.2.7></a>4.2.7 )OUT</h4>Syntax: <b>)OUT filename [object ...]</b><br><br>Like <b>)SAVE</b> below, but using a different file format. The files have an
extension of <b>.atf</b> (for APL Transfer File). Even though the <b>)SAVE</b>
command itself is standardized (in the ISO standard), the file format that
it produces is not. In contrast, the file format produced by <b>)OUT</b> and
understood by <b>)IN</b> is supposed to be understood by different APL
interpreters of different vendors, so that workspaces can, at least in
principle, be exchanged using <b>)IN</b> and <b>)OUT</b>.<br><br>Some vendors have extended the <b>.atf</b> file format, which undermines its
primary purpose. GNU APL only supports the original format as described in
the IBM <i>APL2 Language Reference Manual</i>.<h4><a id=CH_4.2.8></a>4.2.8 )OFF</h4>Syntax: <b>)OFF</b><br><br>Exit the APL interpreter with exit code 0.<br><br>Syntax: <b>)OFF [exit_code]</b><br><br>Exit the APL interpreter with the given exit code.<h4><a id=CH_4.2.9></a>4.2.9 )PCOPY</h4>Syntax: <b>)PCOPY [lib] wsname [object ...]</b><br><br>Protective <b>)COPY</b>. Same as <b>)COPY</b> above, but not overwriting existing
defined functions and variables.<h4><a id=CH_4.2.10></a>4.2.10 )PIN</h4>Syntax: <b>)PIN filename [object ...]</b><br><br>Protective <b>)IN</b>. Same as <b>)IN</b> above, but not overwriting existing
defined functions and variables.<h4><a id=CH_4.2.11></a>4.2.11 )RESET</h4>Syntax: <b>)RESET</b><br><br>Same as <b>)CLEAR</b> above.<h4><a id=CH_4.2.12></a>4.2.12 )SYMBOLS</h4>Syntax: <b>)SYMBOLS [count]</b><br><br>If <b>count</b> is ommitted then display the current number of user-defined
names (i.e. for variables, labels, defined functions and defined operators).
Otherwise, increase the size of the symbol table to at least <b>count</b>.<h3><a id=CH_4.3></a>4.3 Additional GNU APL Commands</h3>In addition to the commands from the ISO standard and from IBM APL2, GNU APL
provides some more commands. These commands are divided into 2 groups: normal
commands that start with the character <b>)</b>, and debug commands that
start with the character <b>]</b>.<h4><a id=CH_4.3.1></a>4.3.1 )DUMP</h4>Syntax: <b>)DUMP [[lib] wsname]</b><br><br>Like <b>)SAVE</b> below, but using a different file format. The files have an
extension of <b>.apl</b>. The file produced is an APL script which, when executed,
reconstructs the current workspace (in terms of variables, defined functions,
and defined operators).<br><br>The .apl files produced by <b>)DUMP</b> are easier to read (and, if necessary,
to modify) than the .xml files produced by <b>)SAVE</b>. On the one hand, .apl
files are more portable than .xml files, both in respect to different versions
of the GNU APL interpreter and with respect to interpreters from different APL
vendors. On the other hand, .apl files have limitations when used with
<b>)COPY</b> in <b>libapl</b>.<br><br><h4><a id=CH_4.3.2></a>4.3.2 )DUMP-HTML</h4>Syntax: <b>)DUMP-HTML [[lib] wsname]</b><br><br><b>lib</b> is an optional library reference number as for command <b>)COPY</b>
above.<br><br><b>wsname</b> selects a workspace in the directory selected by <b>lib</b>. If
<b>lib</b> is omitted then an absolute path to the workspace file is accepted
as <b>wsname</b>.<br><br>)DUMP-HTML is similar to )DUMP, but it adds some HTML tagging so that the
output file (with file extension .html) can be directly displayed by a web
server. This can be useful for sharing your workspaces on the web in such
a way that other users can cut-and-paste your code into their GNU APL session.<h4><a id=CH_4.3.3></a>4.3.3 )HIST</h4>Syntax: <b>)HIST</b> ⍝ show entire history
Syntax: <b>)HIST CLEAR</b> ⍝ clear the history
Syntax: <b>)HIST filter</b> ⍝ show only history lines starting with <b>filter</b><br><br>)HIST displays previously entered lines. It is sometimes difficult to remember
the APL input that has lead to an APL error, and this command may help to
reproduce such errors.
If called with an argument, then argument CLEAR clears the history, while
any other argument is taken as display filter. Only history lines beginning
with the given filter are being displayed.<h4><a id=CH_4.3.4></a>4.3.4 )LIBS</h4>Syntax: <b>)LIBS</b><br><br>Display the current mapping from library reference numbers to directories. For
example:<pre class=input_T line=664>      )LIBS</pre><pre class=output line=731>Library root: /home/eedjsa/apl-1.9

Library reference number to (absolute) path mapping:

╔═══╤═════╤═════════════╤══════════════════════════════════════════════════════╗
║Ref│Conf │State (errno)│ Path to the directory containing the workspace files ║
╟───┼─────┼─────────────┼──────────────────────────────────────────────────────╢
║ 0 │PWD  │ present     │ /home/eedjsa/apl-1.9/workspaces                      ║
║ 1 │PWD  │ present     │ /home/eedjsa/apl-1.9/wslib1                          ║
║ 2 │PWD  │ present     │ /home/eedjsa/apl-1.9/wslib2                          ║
║ 3 │PSYS │ present     │ /usr/local/lib/apl/wslib3                            ║
║ 4 │PSYS │ present     │ /usr/local/lib/apl/wslib4                            ║
║ 5 │PSYS │ present     │ /usr/local/lib/apl/wslib5                            ║
║ 6 │PWD  │ present     │ /home/eedjsa/apl-1.9/wslib6                          ║
║ 7 │PWD  │ missing (2) │ /home/eedjsa/apl-1.9/wslib7                          ║
║ 8 │PWD  │ missing (2) │ /home/eedjsa/apl-1.9/wslib8                          ║
║ 9 │PWD  │ missing (2) │ /home/eedjsa/apl-1.9/wslib9                          ║
╚═══╧══╤══╧═════════════╧══════════════════════════════════════════════════════╝
       │
       ├── NONE:  found no method to compute the library path
       ├── CMD:   the path was set with )LIBS N path
       ├── ENV:   the path came from environment variable $APL_LIB_ROOT
       ├── PSYS:  the path came from the system preferences in file
       │                   /usr/local/etc/gnu-apl.d/preferences
       ├── PUSER: the path came from user preferences in file
       │                   $HOME/.config/gnu-apl or $HOME/.gnu-apl
       └── PWD:   the path is relative to current directory $PWD (last resort)
</pre><br><br>Syntax: <b>)LIBS [lib] path</b><br><br><b>lib</b> is an optional library reference number as for command <b>)COPY</b>
above.<br><br>The directory for library reference number <b>lib</b> is set to <b>path</b>.<h4><a id=CH_4.3.5></a>4.3.5 )QLOAD</h4>Syntax: <b>)QLOAD [lib] wsname</b><br><br>Quiet <b>)LOAD</b>. Like <b>)LOAD</b>) above, but without printing a <b>SAVED...</b>
or <b>DUMPED ...</b> message.<h4><a id=CH_4.3.6></a>4.3.6 )VALUES</h4>Syntax: <b>)VALUES</b><br><br>Display a (long) list of all APL values (not variables) currently known
by the interpreter along with their status (for debug purposes).<h4><a id=CH_4.3.7></a>4.3.7 ]BOXING</h4>Syntax: <b>]BOXING [OFF|2|3|4|7|8|9]</b><br><br>Changes the default style of the APL output. Example:<pre class=input_T line=664>      V←1 (2 3) 'Hello'</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      ]BOXING OFF</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V</pre><pre class=output1 line=732> 1  2 3  Hello
</pre><pre class=input_ line=665>      ]BOXING 4</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V</pre><pre class=output1 line=732>┏→━━━━━━━━━━━━━━┓
┃1 ┏→━━┓ ┏→━━━━┓┃
┃  ┃2 3┃ ┃Hello┃┃
┃  ┗━━━┛ ┗━━━━━┛┃
┗ϵ━━━━━━━━━━━━━━┛
</pre><pre class=input_ line=665>      ]BOXING 8</pre><pre class=output1 line=720></pre><pre class=input_ line=665>      V</pre><pre class=output1 line=732>┌→──────────────┐
│1 ┌→──┐ ┌→────┐│
│  │2 3│ │Hello││
│  └───┘ └─────┘│
└ϵ──────────────┘
</pre><pre class=input_ line=665>      ]BOXING OFF</pre><pre class=output1 line=720></pre><pre class=output line=908></pre><h4><a id=CH_4.3.8></a>4.3.8 ]COLOR</h4>Syntax: <b>]COLOR [ON|OFF]</b><br><br>Enables or disables the emission of Escape sequences for colors in the APL
output. Output coloring is typically useful in truly interactive mode but
requires terminals or terminal windows that support the Escape sequences.
There are many situations, however, in which these Escape sequences disturb
more than they help, e.g. copy-and-paste between terminal windows,
post-processing of APL output.<h4><a id=CH_4.3.9></a>4.3.9 ]DOXY</h4>Syntax: <b>]DOXY [path]</b><br><br>Produce a Doxgen-like documentation of the current workspace. If <b>path</b>
is omitted then current directory is used as <b>path</b>. Example:<pre class=input_T line=664>      ⍝ ]DOXY refuses to overwrite existing directories.</pre><pre class=input_ line=665>      )HOST rm -Rf /tmp/DOXY_TEST</pre><pre class=output1 line=732>0
</pre><pre class=input_ line=665>      )WSID DOXY_TEST</pre><pre class=output1 line=732>WAS CLEAR WS
</pre><pre class=input_ line=665>      ]DOXY /tmp</pre><pre class=output1 line=732>Command ]DOXY finished successfully.
    The generated documentation was stored in directory /tmp/DOXY_TEST
    You may now browse it from file:///tmp/DOXY_TEST/index.html
</pre><pre class=output line=908></pre><h4><a id=CH_4.3.10></a>4.3.10 ]EXPECT</h4>Syntax: <b>]EXPECT error_count</b><br><br>Accept up to <b>error_count</b> errors before a testcase is considered failed.<h4><a id=CH_4.3.11></a>4.3.11 ]KEYB</h4>Syntax: <b>]KEYB</b><br><br>Display an APL Keyboard that can, for example, be used for cut-and-paste of
APL characters on keyboards that cannot produce them. For example:<pre class=input_T line=664>      ]KEYB</pre><pre class=output1 line=732>US Keyboard Layout:

╔════╦════╦════╦════╦════╦════╦════╦════╦════╦════╦════╦════╦════╦═════════╗
║ ~  ║ !⌶ ║ @⍫ ║ #⍒ ║ $⍋ ║ %⌽ ║ ^⍉ ║ &amp;⊖ ║ *⍟ ║ (⍱ ║ )⍲ ║ _! ║ +⌹ ║         ║
║ `◊ ║ 1¨ ║ 2¯ ║ 3&lt; ║ 4≤ ║ 5= ║ 6≥ ║ 7&gt; ║ 8≠ ║ 9∨ ║ 0∧ ║ -× ║ =÷ ║ BACKSP  ║
╠════╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦═╩══╦══════╣
║       ║ Q  ║ W⍹ ║ E⍷ ║ R  ║ T⍨ ║ Y¥ ║ U  ║ I⍸ ║ O⍥ ║ P⍣ ║ {⍞ ║ }⍬ ║  |⊣  ║
║  TAB  ║ q? ║ w⍵ ║ eϵ ║ r⍴ ║ t∼ ║ y↑ ║ u↓ ║ i⍳ ║ o○ ║ p⋆ ║ [← ║ ]→ ║  \⊢  ║
╠═══════╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩═╦══╩══════╣
║ (CAPS   ║ A⍶ ║ S  ║ D  ║ F  ║ G  ║ H  ║ J⍤ ║ K  ║ L⌷ ║ :≡ ║ "≢ ║         ║
║  LOCK)  ║ a⍺ ║ s⌈ ║ d⌊ ║ f_ ║ g∇ ║ h∆ ║ j∘ ║ k' ║ l⎕ ║ ;⍎ ║ '⍕ ║ RETURN  ║
╠═════════╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═══╦╩═════════╣
║             ║ Z  ║ Xχ ║ C¢ ║ V  ║ B£ ║ N  ║ M  ║ &lt;⍪ ║ &gt;⍙ ║ ?⍠ ║          ║
║  SHIFT      ║ z⊂ ║ x⊃ ║ c∩ ║ v∪ ║ b⊥ ║ n⊤ ║ m| ║ ,⍝ ║ .⍀ ║ /⌿ ║  SHIFT   ║
╚═════════════╩════╩════╩════╩════╩════╩════╩════╩════╩════╩════╩══════════╝

</pre><pre class=output line=908></pre>The user may change the keyboard that is displayed with <b>]KEYB</b>, see e.g.
<b>/usr/local/etc/gnu-apl.d/keyboard1.txt</b>.<h4><a id=CH_4.3.12></a>4.3.12 ]LOG</h4>Syntax: <b>]LOG [facility [ON|OFF]]</b><br><br>Lists or controls GNU APL logging facilities (if configured to do so).<h4><a id=CH_4.3.13></a>4.3.13 ]NEXTFILE</h4>Syntax: <b>]NEXTFILE</b><br><br>GNU APL can be started with no, one, or muktiple input files. The
<b>]NEXTFILE</b> command abortes the execution of the current input file and
starts the execution of the next file (if any). If there is no next file
then it prints an error message and enters immediate execution mode.<h4><a id=CH_4.3.14></a>4.3.14 ]OWNERS</h4>Syntax: <b>]OWNERS</b><br><br>Displays some debug information related to all APL values.<h4><a id=CH_4.3.15></a>4.3.15 ]SVARS</h4>Syntax: <b>]SVARS</b><br><br>Displays some debug information related to <i>shared variables</i>
(an obsolete APL feature that is still supported by GNU APL).<h4><a id=CH_4.3.16></a>4.3.16 ]SYMBOL</h4>Syntax: <b>]SYMBOL name</b><br><br>Displays some debug information related to <b>name</b>.<h4><a id=CH_4.3.17></a>4.3.17 ]USERCMD</h4>GNU APL allows the creation of new APL commands by the user. These commands are
implemented as APL code, either as lambdas (for simple commands) or as defined
functions (for more complex commands).<br><br>Syntax: <b>]USERCMD</b><br><br>Display all currently defined user commands.<br><br>Syntax: <b>]USERCMD )ucmd APL_fun [mode]</b><br><br>Syntax: <b>]USERCMD ]ucmd APL_fun [mode]</b><br><br>Define a new user-defined command by means of a defined function. The entire
command is passed to the defined function as a string, therefore the function
usually needs to drop the name of the command.<br><br><ul><li>If the optional <b>mode</b> is 0 (which is the default) then <b>APL_fun</b>
shall be monadic and the command entered by the user is passed to <b>APL_fun</b>
as an APL string (starting with the command name). <b>APL_fun</b> is responsible
for parsing the string, typically at least dropping the name of the command.<li>If the optional <b>mode</b> is 1 then <b>APL_fun</b> shall be dyadic. The right
argument of <b>APL_fun</b> is the same as for mode 0, while the left argument
is a nested vector of APL strings. This vector contains the tokenized right
argument which somewhat simplifies the processing of the argument(s) with which
the user-defined command was called. The first item of the vector is the
command, the next item is the first argument (if provided), and so on.</ul>It is possible to use the same defined function for different user-defined
commands.<br><br>Syntax: <b>]USERCMD )ucmd { ... }</b>
Syntax: <b>]USERCMD ]ucmd { ... }</b><br><br>Define a new user defined command by means of a monadic lambda expression.
The entire command is passed to the lambda expression as a string, therefore
the lambda expression needs to drop e.g. the name of the command. Example:<br><br>First define the command:<pre class=input_T line=664>      ]USERCMD )sum { +/⍎4↓⍵ }</pre><pre class=output line=731>    User-defined command )sum installed.
</pre>Then use the new command:<pre class=input_T line=868>      )sum 1 2 3</pre><pre class=output line=908>6</pre><br>Syntax: <b>]USERCMD REMOVE ]ucmd</b><br><br>Delete the previously defined user command <b>]ucmd</b>. Example:<pre class=input_T line=664>      ]USERCMD REMOVE )sum</pre><pre class=output line=731>    User-defined command )sum removed.
</pre>Syntax: <b>]USERCMD REMOVE-ALL</b><br><br>Delete all currently defined user commands.<pre class=input_T line=664>      ]USERCMD REMOVE-ALL</pre><pre class=output line=731>    All user-defined commands removed.
</pre><h4><a id=CH_4.3.18></a>4.3.18 ]XTERM</h4>Syntax: <b>]XTERM [ON|OFF]</b><br><br>GNU APL assumes, by default, that it runs interactively in an xterm compatible
terminal or terminal emulator such as <b>xterm</b>. In some situations it needs
to output Escape sequences, e.g. for positioning the cursor or for clearing
lines. In some situations (see command <b>]COLOR</b>) these Escape sequences
are not desired and their emission can be turned off with command <b>XTERM</b><br><br>